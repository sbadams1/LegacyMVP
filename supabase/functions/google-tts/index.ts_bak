// supabase/functions/google-tts/index.ts
//
// Simple Text-to-Speech proxy for the Legacy app.
//
// Usage (from Flutter):
//   supabase.functions.invoke('google-tts', body: {
//     text: 'Hello from the Legacy app',
//     primary_language: 'en-US',      // ✅ preferred field (or 'en', 'th', 'es-MX', etc.)
//     voice_id: 'en-US-Neural2-A',    // optional override
//     gender: 'NEUTRAL',              // optional
//     speakingRate: 1.0               // optional
//   });
//
// Response:
//   { audioContent: string }  // base64-encoded MP3
//   or { error, details, googleError }

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

type TtsBody = {
  text?: string;
  primary_language?: string;  // e.g. 'en', 'en-US', 'th-TH'
  languageCode?: string;      // kept for backward compatibility
  voice_id?: string;          // preferred explicit voice name
  voiceName?: string;         // backward compatibility
  gender?: "MALE" | "FEMALE" | "NEUTRAL";
  speakingRate?: number;
};

// -----------------------------------------------------------------------------
// Google voice map
// -----------------------------------------------------------------------------

type VoiceConfig = { languageCode: string; voiceName: string };

// Common natural-sounding Google Cloud TTS voices (Neural2 where available).
// Keys are normalized to lowercase (e.g. 'en', 'en-us', 'th-th').
const GOOGLE_VOICE_MAP: Record<string, VoiceConfig> = {
  // English
  "en":      { languageCode: "en-US", voiceName: "en-US-Neural2-D" },
  "en-us":   { languageCode: "en-US", voiceName: "en-US-Neural2-D" },
  "en-gb":   { languageCode: "en-GB", voiceName: "en-GB-Neural2-A" },

  // Thai
  "th":      { languageCode: "th-TH", voiceName: "th-TH-Neural2-A" },
  "th-th":   { languageCode: "th-TH", voiceName: "th-TH-Neural2-A" },

  // Spanish
  "es":      { languageCode: "es-ES", voiceName: "es-ES-Neural2-B" },
  "es-es":   { languageCode: "es-ES", voiceName: "es-ES-Neural2-B" },
  "es-mx":   { languageCode: "es-MX", voiceName: "es-MX-Neural2-A" },

  // French
  "fr":      { languageCode: "fr-FR", voiceName: "fr-FR-Neural2-D" },
  "fr-fr":   { languageCode: "fr-FR", voiceName: "fr-FR-Neural2-D" },

  // German
  "de":      { languageCode: "de-DE", voiceName: "de-DE-Neural2-D" },
  "de-de":   { languageCode: "de-DE", voiceName: "de-DE-Neural2-D" },

  // Portuguese (Brazil)
  "pt-br":   { languageCode: "pt-BR", voiceName: "pt-BR-Neural2-A" },

  // Japanese
  "ja":      { languageCode: "ja-JP", voiceName: "ja-JP-Neural2-D" },
  "ja-jp":   { languageCode: "ja-JP", voiceName: "ja-JP-Neural2-D" },

  // Korean
  "ko":      { languageCode: "ko-KR", voiceName: "ko-KR-Neural2-A" },
  "ko-kr":   { languageCode: "ko-KR", voiceName: "ko-KR-Neural2-A" },

  // Mandarin Chinese
  "zh":      { languageCode: "cmn-CN", voiceName: "cmn-CN-Neural2-A" },
  "zh-cn":   { languageCode: "cmn-CN", voiceName: "cmn-CN-Neural2-A" },
  "cmn-cn":  { languageCode: "cmn-CN", voiceName: "cmn-CN-Neural2-A" },
};

// Normalize things like 'EN-us' → 'en-us'
function normalizeLang(code: string | undefined | null): string {
  if (!code) return "en-us";
  return code.trim().toLowerCase();
}

function resolveVoice(preferredLanguage?: string): VoiceConfig {
  const norm = normalizeLang(preferredLanguage);

  // Exact match (e.g. 'th-th', 'es-mx')
  if (GOOGLE_VOICE_MAP[norm]) {
    return GOOGLE_VOICE_MAP[norm];
  }

  // Try base language (e.g. 'th', 'es') if region was unknown
  const base = norm.split("-")[0];
  if (GOOGLE_VOICE_MAP[base]) {
    return GOOGLE_VOICE_MAP[base];
  }

  // Fallback to US English
  return GOOGLE_VOICE_MAP["en-us"];
}

serve(async (req: Request): Promise<Response> => {
  // CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 204,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers":
          "authorization, x-client-info, apikey, content-type",
      },
    });
  }

  if (req.method !== "POST") {
    return jsonResponse({ error: "Method not allowed" }, 405);
  }

  try {
    const body = (await req.json()) as TtsBody;

    const text = body.text?.trim();
    if (!text) {
      return jsonResponse({ error: "text is required" }, 200);
    }

    // Prefer dedicated TTS key, fall back to speech key if you want
    const apiKey =
      Deno.env.get("GOOGLE_TTS_API_KEY") ??
      Deno.env.get("GOOGLE_SPEECH_API_KEY");

    if (!apiKey) {
      return jsonResponse(
        { error: "GOOGLE_TTS_API_KEY (or GOOGLE_SPEECH_API_KEY) is not set" },
        200,
      );
    }

    // ✅ Prefer primary_language, but accept legacy languageCode
    const requestedLanguage =
      body.primary_language?.trim() ||
      body.languageCode?.trim() ||
      "en-US";

    // Resolve languageCode + default voice based on our map
    const defaultVoice = resolveVoice(requestedLanguage);

    // Gender is optional; Neural2 voices generally sound good with NEUTRAL or MALE
    const gender = body.gender || "NEUTRAL";

    // ✅ Prefer explicit voice_id, then legacy voiceName, then our mapped default
    const voiceName =
      body.voice_id?.trim() ||
      body.voiceName?.trim() ||
      defaultVoice.voiceName;

    const languageCode = defaultVoice.languageCode;

    const ttsReq = {
      input: { text },
      voice: {
        languageCode,
        name: voiceName,
        ssmlGender: gender,
      },
      audioConfig: {
        audioEncoding: "MP3",
        // You can tweak this slightly (e.g. 0.9) if you want a bit slower speech
        speakingRate: body.speakingRate ?? 1.0,
      },
    };

    const ttsRes = await fetch(
      "https://texttospeech.googleapis.com/v1/text:synthesize?key=" + apiKey,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(ttsReq),
      },
    );

    const textRes = await ttsRes.text();
    let json: any;
    try {
      json = JSON.parse(textRes);
    } catch {
      json = textRes;
    }

    if (!ttsRes.ok) {
      console.error("Google TTS error:", ttsRes.status, textRes);
      return jsonResponse(
        {
          error: "Google TTS error",
          details: `HTTP ${ttsRes.status}`,
          googleError: json,
        },
        200,
      );
    }

    const audioContent = (json as any).audioContent;
    if (!audioContent) {
      return jsonResponse(
        { error: "No audioContent in TTS response", googleError: json },
        200,
      );
    }

    return jsonResponse({ audioContent }, 200);
  } catch (err) {
    console.error("google-tts function error:", err);
    return jsonResponse(
      { error: "Server error", details: String(err) },
      200,
    );
  }
});

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
    },
  });
}
