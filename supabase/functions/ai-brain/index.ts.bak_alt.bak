// supabase/functions/ai-brain/index.ts
//
// Gemini 2.0 Flash Experimental "brain" for LegacyMVP.
// Supports:
// - Legacy mode: chapter-based interviews
// - Language learning mode: unit/lesson-based tutoring
//
// Now includes:
// - state_json for minimal structured state (legacy & language modes)
// - Strong anti-JSON / anti-Markdown rules for language-learning
// - sanitizeGeminiOutput() to strip code fences / JSON wrappers

import "jsr:@supabase/functions-js/edge-runtime.d.ts";

import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.48.0";
import {
  chooseExpansionForConcept,
  getConceptWithExpansion,
  PronunciationDrill,
  buildPronunciationDrill,
} from "../_shared/vocabulary.ts"; // adjust relative path if needed

// ============================================================================
// ENV VARS & MODEL
// ============================================================================

const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error("❌ SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY is not set.");
}

const supabase = SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY
  ? createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
      auth: { persistSession: false },
    })
  : null;

const GEMINI_API_KEY =
  Deno.env.get("GEMINI_API_KEY") ?? Deno.env.get("GEMINI_API_KEY_EDGE");

const GEMINI_MODEL =
  Deno.env.get("GEMINI_MODEL") ?? "models/gemini-2.0-flash-exp";

if (!GEMINI_API_KEY) {
  console.error("❌ GEMINI_API_KEY is NOT set in Supabase environment.");
}

// ============================================================================
// Types
// ============================================================================
type ConversationMode = "legacy" | "language_learning" | "avatar";
type LearningLevel = "beginner" | "intermediate" | "advanced";
type SupabaseClient = ReturnType<typeof createClient>;

interface AiBrainPayload {
  user_id: string;
  conversation_id?: string;
  message_text: string;
  mode?: ConversationMode;
  preferred_locale?: string;
  target_locale?: string | null;
  learning_level?: LearningLevel;

  // Optional per-request persona override for legacy mode.
  // Allowed values match ConversationPersona: "adaptive" | "playful" | "grounded".
  conversation_persona?: ConversationPersona;

  // optional structured state
  state_json?: string | null;
}

// Optional: only needed if you later fetch from the profiles table directly
interface ProfileLanguages {
  preferred_language?: string | null;
  supported_languages?: string[] | null;
}

// --- Session-level legacy summarizer (Option A) -----------------------------

interface LegacyTranscriptTurn {
  role: "user" | "assistant";
  text: string;
}

/**
 * Ask Gemini for a session-level summary of a legacy conversation.
 * Returns { short_summary, full_summary }.
 * If Gemini is unavailable, falls back to a naive summary.
 */
async function summarizeLegacySessionWithGemini(
  transcript: LegacyTranscriptTurn[],
): Promise<{ short_summary: string; full_summary: string }> {
  // Naive fallback if we have nothing or no Gemini key.
  if (!transcript.length || !GEMINI_API_KEY) {
    const joined = transcript.map((t) => t.text).join(" ");
    const trimmed = joined.replace(/\s+/g, " ").trim();
    const shortSummary =
      trimmed.length > 160 ? `${trimmed.slice(0, 157)}...` : trimmed || "Legacy session";
    const fullSummary =
      trimmed.length > 400 ? `${trimmed.slice(0, 397)}...` : trimmed || shortSummary;
    return { short_summary: shortSummary, full_summary: fullSummary };
  }

  // Trim the transcript to keep prompt size under control (approx char-based).
  const MAX_CHARS = 8000;
  const trimmed: LegacyTranscriptTurn[] = [];
  let total = 0;
  // Walk from the end backwards, then reverse to restore chronological order.
  for (let i = transcript.length - 1; i >= 0; i--) {
    const t = transcript[i];
    const len = t.text.length;
    if (total + len > MAX_CHARS && trimmed.length > 0) break;
    trimmed.push(t);
    total += len;
  }
  trimmed.reverse();

  const transcriptText = trimmed
    .map((t) => `${t.role === "user" ? "USER" : "AI"}: ${t.text}`)
    .join("\n");

  const prompt = `
You are an expert autobiographical editor summarizing a *legacy preservation* interview.

You will receive a transcript of a single session between a PERSON (USER) and an AI assistant (AI). 
Your job is to ignore technical chatter (e.g., about apps, STT, Supabase, Gemini, tests, coverage maps, debugging)
and focus purely on the person's life experiences, memories, and feelings.

From the transcript below, produce:
1) "short_summary": ONE clear sentence in third person that captures the core of what the person talked about.
2) "full_summary": 1–3 short paragraphs in third person that capture the key memories, details, and themes.
   - Focus on biographical facts (places, dates, careers, relationships, important events).
   - Do NOT mention that this is an app, AI, debugging, or testing.
   - Do NOT say things like "In this conversation, they talked about..."; just tell the story directly.

Return ONLY a valid JSON object with this exact shape:
{
  "short_summary": "...",
  "full_summary": "..."
}

Transcript:
${transcriptText}
`.trim();

  const body = {
    contents: [
      {
        role: "user",
        parts: [{ text: prompt }],
      },
    ],
  };

  try {
    const resp = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(body),
      },
    );

    if (!resp.ok) {
      console.error(
        "summarizeLegacySessionWithGemini: non-OK response",
        resp.status,
        await resp.text(),
      );
      throw new Error(`Gemini error ${resp.status}`);
    }

    const json = await resp.json();
    const text =
      json?.candidates?.[0]?.content?.parts?.[0]?.text ??
      json?.candidates?.[0]?.content?.parts?.[0]?.rawText ??
      "";

    let parsed: any;
    try {
      parsed = JSON.parse(text);
    } catch {
      // Sometimes Gemini wraps JSON in prose; try to extract a JSON block.
      const match = String(text).match(/\{[\s\S]*\}/);
      if (!match) throw new Error("No JSON block found in Gemini text");
      parsed = JSON.parse(match[0]);
    }

    const shortSummary =
      (parsed?.short_summary as string | undefined)?.trim() ?? "";
    const fullSummary =
      (parsed?.full_summary as string | undefined)?.trim() ?? "";

    if (!shortSummary || !fullSummary) {
      throw new Error("Missing short_summary or full_summary in Gemini JSON");
    }

    return { short_summary: shortSummary, full_summary: fullSummary };
  } catch (err) {
    console.error("summarizeLegacySessionWithGemini failed, using fallback:", err);

    const joined = transcript.map((t) => t.text).join(" ");
    const trimmed = joined.replace(/\s+/g, " ").trim();
    const shortSummary =
      trimmed.length > 160 ? `${trimmed.slice(0, 157)}...` : trimmed || "Legacy session";
    const fullSummary =
      trimmed.length > 400 ? `${trimmed.slice(0, 397)}...` : trimmed || shortSummary;
    return { short_summary: shortSummary, full_summary: fullSummary };
  }
}

/**
 * Fetch the existing transcript for a legacy session from memory_raw.
 * We return a list of { role, text } turns ordered by created_at.
 */
async function fetchLegacySessionTranscript(
  client: SupabaseClient,
  userId: string,
  conversationId: string,
): Promise<LegacyTranscriptTurn[]> {
  try {
    const { data, error } = await client
      .from("memory_raw")
      .select("role, content")
      .eq("user_id", userId)
      .eq("conversation_id", conversationId)
      .order("created_at", { ascending: true })
      .limit(200);

    if (error) {
      console.error("fetchLegacySessionTranscript error:", error);
      return [];
    }

    const transcript: LegacyTranscriptTurn[] = [];
    for (const row of data ?? []) {
      const anyRow = row as any;
      const text = (anyRow.content as string | null) ?? "";
      const roleRaw = (anyRow.role as string | null) ?? "user";
      const trimmed = text.trim();
      if (!trimmed) continue;

      const role: "user" | "assistant" =
        roleRaw === "assistant" ? "assistant" : "user";

      transcript.push({ role, text: trimmed });
    }

        return transcript;
  } catch (err) {
    console.error("fetchLegacySessionTranscript exception:", err);
    return [];
  }
}

// ------- LEGACY STATE & CATALOG --------------------------------------------
interface LegacyInterviewState {
  chapter_id: string;
  chapter_title: string;
  progress_percent: number; // 0–100
  focus_topic: string | null;
}

interface LegacyChapterConfig {
  chapter_id: string;
  chapter_title: string;
  goal: string;
  default_focus_topic: string | null;
  topics: string[];
}

interface LegacyPromptContext {
  // Persona flavor for the conversation ("adaptive", "playful", "grounded").
  persona: ConversationPersona;

  // Optional: a display name if you later pull it from profiles.
  userDisplayName?: string | null;

  // Language routing
  preferredLocale: string;
  targetLocale: string | null;

  // Optional: brief natural-language summary of coverage so far.
  coverageSummary?: string | null;

  // Current minimal state for the legacy interview.
  legacyState: LegacyInterviewState;

  // The chapter config the model should treat as "current".
  currentChapter: LegacyChapterConfig;
}

// Expanded catalog of life chapters.
// NOTE: We keep "childhood" and "early_career" for backward compatibility
// with any existing state_json, and add additional stages.
const LEGACY_CHAPTERS: Record<string, LegacyChapterConfig> = {
  childhood: {
    chapter_id: "childhood",
    chapter_title: "Childhood & Family Background",
    goal:
      "Capture memories about family, home environment, early influences, and early school years.",
    default_focus_topic: "family_background",
    topics: [
      "family_background",
      "childhood_home",
      "siblings_and_parents",
      "school_years",
      "friends_and_play",
      "earliest_memory",
    ],
  },

  adolescence: {
    chapter_id: "adolescence",
    chapter_title: "Adolescence & Teenage Years",
    goal:
      "Capture stories from the teen years: identity, school, friendships, early independence, and formative experiences.",
    default_focus_topic: "high_school_years",
    topics: [
      "high_school_years",
      "close_friendships",
      "early_romantic_relationships",
      "sports_and_activities",
      "big_mistakes_and_lessons",
    ],
  },

  early_career: {
    chapter_id: "early_career",
    chapter_title: "Early Career & First Jobs",
    goal:
      "Capture stories about first serious jobs, career direction, mentors, early wins, failures, and early adult independence.",
    default_focus_topic: "first_full_time_job",
    topics: [
      "first_full_time_job",
      "why_chosen_field",
      "early_mentors",
      "early_failures",
      "early_successes",
      "moving_out_on_your_own",
    ],
  },

  midlife: {
    chapter_id: "midlife",
    chapter_title: "Midlife, Responsibility & Growth",
    goal:
      "Capture stories from the middle stretch of life: work responsibilities, parenting, big projects, major stresses, and achievements.",
    default_focus_topic: "mid_career_responsibilities",
    topics: [
      "mid_career_responsibilities",
      "raising_children_or_guiding_others",
      "financial_highs_and_lows",
      "stress_and_burnout",
      "proudest_midlife_achievements",
    ],
  },

  later_life: {
    chapter_id: "later_life",
    chapter_title: "Later Life & Reflection",
    goal:
      "Capture reflections from later years: retirement, slowing down, health, legacy, and hopes for the future.",
    default_focus_topic: "retirement_transition",
    topics: [
      "retirement_transition",
      "changes_in_daily_routine",
      "health_challenges",
      "maintaining_purpose",
      "lessons_for_future_generations",
    ],
  },

  family_relationships: {
    chapter_id: "family_relationships",
    chapter_title: "Family, Relationships & Loved Ones",
    goal:
      "Capture stories about close relationships: partners, children, siblings, parents, and chosen family.",
    default_focus_topic: "most_important_relationships",
    topics: [
      "meeting_a_partner",
      "marriage_or_long_term_partnership",
      "children_and_parenting",
      "relationship_challenges",
      "most_important_relationships",
      "what_love_means_to_you",
    ],
  },

  beliefs_values: {
    chapter_id: "beliefs_values",
    chapter_title: "Beliefs, Values & Meaning",
    goal:
      "Capture how the donor thinks about meaning, morality, spirituality or worldview, and how values guided their choices.",
    default_focus_topic: "guiding_values",
    topics: [
      "guiding_values",
      "beliefs_about_right_and_wrong",
      "spiritual_or_philosophical_views",
      "how_values_changed_over_time",
      "what_you_hope_to_pass_on",
    ],
  },

  hobbies_interests: {
    chapter_id: "hobbies_interests",
    chapter_title: "Hobbies, Interests & Passions",
    goal:
      "Capture stories about activities that brought joy, curiosity, or flow across the years.",
    default_focus_topic: "favorite_hobby",
    topics: [
      "favorite_hobby",
      "creative_pursuits",
      "sports_and_outdoors",
      "learning_new_skills",
      "how_you_relax_and_have_fun",
    ],
  },

  major_events: {
    chapter_id: "major_events",
    chapter_title: "Major Life Events & Turning Points",
    goal:
      "Capture the key turning points: moves, losses, crises, triumphs, and decisions that changed the course of life.",
    default_focus_topic: "biggest_turning_point",
    topics: [
      "biggest_turning_point",
      "relocating_to_a_new_place",
      "career_pivots",
      "serious_losses_or_grief",
      "moments_of_breakthrough_or_reinvention",
    ],
  },
};

interface LanguageTargetPhrase {
  /** Main phrase in the target language script (Thai, etc.) */
  l2_script: string;

  /** Stable concept key from concept_master (e.g. "RUN_PHYSICAL_MOVE"). */
  concept_key?: string;

  /** Short L1 gloss for the learner (e.g. "run (physically)"). */
  l1_gloss?: string;

  /** Optional IPA transcription for internal use. */
  ipa?: string;

  /** Optional L2 example sentence using this phrase. */
  example_l2?: string;

  /** Optional L1 translation of that example sentence. */
  example_l1?: string;

  /** Optional structured drill recipe derived from vocabulary_expansions.drill_steps. */
  drill?: PronunciationDrill | null;
}

interface LanguageLessonState {
  unit_id: string; // e.g. U1_GREETINGS
  lesson_id: string; // e.g. L1_HELLO_BASICS
  stage: string; // intro | guided_practice | free_practice | review
  target_phrases: LanguageTargetPhrase[];
  // How many times the learner has seen/practiced the main phrase for this lesson.
  times_seen_main_phrase: number;
  // Whether the learner is considered to have basically mastered the main phrase.
  has_mastered_main_phrase: boolean;
}

// Qualitative observations about a single distilled memory summary.
// All scores are 0–1, where higher means "more of this quality".
interface MemorySummaryObservations {
  // Which coverage chapters this summary contributes to.
  chapter_keys?: CoverageChapterKey[];

  // Optional richer chapter entries if/when we add them later.
  coverage_chapters?: {
    key: CoverageChapterKey;
    weight?: number | null;
    confidence?: number | null;
  }[];

  // Optional time span in years.
  start_year?: number;
  end_year?: number;

  // Rough size of the original material.
  word_count_estimate?: number;

  // Tags/themes this memory touches.
  themes?: string[];
  insight_tags?: string[];

  // Qualitative richness (0–1). These will be filled by the summariser.
  narrative_depth_score?: number;     // How much story & concrete detail?
  emotional_depth_score?: number;     // How much emotion is present?
  reflection_score?: number;          // How much “what it meant / what I learned”?
  distinctiveness_score?: number;     // How non-generic / personally specific?

  // Optional pre-computed “this memory is rich” weight (0–1).
  memory_weight?: number;

  // Optional: flags for “don’t over-stereotype this”.
  stereotype_risk_flags?: string[];
}

interface MemorySummaryRow {
  id: string;
  user_id: string;
  raw_id: string;
  created_at: string; // ISO
  short_summary: string | null;
  full_summary: string | null;
  observations: MemorySummaryObservations | null;
}

// ---------------------------------------------------------------------------
// Pronunciation diagnostics (from STT → Gemini → app)
// ---------------------------------------------------------------------------

interface PronunciationWordDiagnostic {
  /** The surface word or chunk in the learner's utterance (L2 script if available). */
  word: string;

  /** Optional IPA for this word or chunk (for the AI, not for direct display). */
  ipa?: string | null;

  /** Start time of this word in the utterance, in milliseconds. */
  start_ms?: number | null;

  /** End time of this word in the utterance, in milliseconds. */
  end_ms?: number | null;

  /**
   * Coarse correctness bucket for this word.
   * - "good": clearly understandable and close to target.
   * - "ok": understandable but with noticeable deviation.
   * - "weak": hard to understand or clearly incorrect.
   */
  correctness: "good" | "ok" | "weak";

  /** Short issue labels for this word, e.g. ["tone", "final_consonant"]. */
  issues: string[];

  /** Concrete tips focused on this word, in L1-language description. */
  tips: string[];
}

interface PronunciationDiagnostic {
  /** Optional ID so the client can correlate this with stored attempts. */
  attempt_id?: string;

  /** Locale used by STT for this utterance, e.g. "th-TH". */
  locale: string;

  /** Target phrase in L2 script that the learner was trying to say. */
  target_phrase_l2: string;

  /** Optional IPA for the target phrase (for the AI's internal use). */
  target_phrase_ipa?: string | null;

  /** Raw transcript text of what the learner actually said (L2). */
  transcript_text: string;

  /** Per-word / per-chunk diagnostics. */
  words: PronunciationWordDiagnostic[];

  /**
   * One or two sentences (in L1) summarising the pronunciation in friendly terms.
   * This is what we will usually show to the learner.
   */
  overall_comment: string;

  /**
   * High-level issue tags across the whole phrase, e.g.
   * ["tones", "final_consonant", "vowel_length"].
   */
  summary_issues: string[];

  /**
   * 1–3 short focus phrases describing what to practice next, e.g.
   * ["keep the last tone low and steady", "hold the long vowel a bit longer"].
   */
  recommended_focus: string[];
}

// NEW: container that tracks progress per language (th, es, etc.)
interface MultiLanguageLessonContainer {
  // version so we can evolve the shape in the future if needed
  version?: number;
  // which language key was active most recently ("th", "es", etc.)
  current_language?: string | null;
  // Map of language key → per-language lesson state
  languages: Record<string, LanguageLessonState>;
}

interface LanguageLessonConfig {
  lesson_id: string;
  lesson_name: string;
  default_stage: string;
  default_target_phrases: LanguageTargetPhrase[];
}

interface LanguageUnitConfig {
  unit_id: string;
  unit_name: string;
  lessons: Record<string, LanguageLessonConfig>;
}

// High-level persona flavors for legacy mode.
export type ConversationPersona = "adaptive" | "playful" | "somber";

// ===== Coverage & Lifetime types =====

export type CoverageChapterKey =
  | "early_childhood"
  | "adolescence"
  | "early_adulthood"
  | "midlife"
  | "later_life"
  | "family_relationships"
  | "work_career"
  | "education"
  | "health_wellbeing"
  | "hobbies_interests"
  | "beliefs_values"
  | "major_events";

export interface CoverageChapter {
  key: CoverageChapterKey;
  label: string;

  // 0.0–1.0; we still store a normalized score here.
  coverage_score: number;

  // Simple counts for debugging + UI.
  memory_count: number;
  word_count_estimate: number;

  // Sum of qualitative “weight” of memories mapped here.
  // A rich, detailed memory will usually contribute somewhere around ~1.0.
  total_weight: number;

  time_span?: {
    start_year?: number;
    end_year?: number;
  };
  last_covered_at?: string;         // ISO
  example_memory_ids: string[];
  summary_snippet?: string;
  open_questions: string[];
  suggested_prompts: string[];
}

export interface CoverageMap {
  version: number;
  user_id: string;
  last_updated: string;
  global: {
    total_memories: number;
    total_words_estimate: number;
    earliest_year?: number;
    latest_year?: number;
    dominant_themes: string[];
  };
  chapters: {
    [key in CoverageChapterKey]: CoverageChapter;
  };
}

function clamp01(value: unknown, fallback = 0): number {
  const n =
    typeof value === "number" && Number.isFinite(value) ? value : fallback;
  if (n <= 0) return 0;
  if (n >= 1) return 1;
  return n;
}

function computeMemoryWeightFromObservations(
  obs: MemorySummaryObservations,
  roughWordCount: number,
): number {
  // If the summariser has explicitly set memory_weight, respect it.
  if (typeof obs.memory_weight === "number") {
    const w = obs.memory_weight;
    if (!Number.isFinite(w)) return 0;
    return Math.max(0, Math.min(1, w));
  }

  const depth =
    typeof obs.narrative_depth_score === "number"
      ? obs.narrative_depth_score
      : 0.3;
  const emotional =
    typeof obs.emotional_depth_score === "number"
      ? obs.emotional_depth_score
      : 0.3;
  const reflection =
    typeof obs.reflection_score === "number"
      ? obs.reflection_score
      : 0.3;
  const distinct =
    typeof obs.distinctiveness_score === "number"
      ? obs.distinctiveness_score
      : 0.3;

  const quality = (depth + emotional + reflection + distinct) / 4;

  // Word-count factor: clips so that long rambling doesn’t explode the score.
  const wcFactor =
    roughWordCount > 0
      ? Math.min(1, Math.log10(roughWordCount + 10) / 3)
      : 0;

  const combined = 0.7 * quality + 0.3 * wcFactor;

  if (!Number.isFinite(combined) || combined <= 0) return 0;
  if (combined > 1) return 1;
  return combined;
}

// ---------------------------------------------------------------------------
// Coverage classification helpers
// ---------------------------------------------------------------------------

function normalizeCoverageChapterKey(
  raw: unknown,
): CoverageChapterKey | null {
  if (typeof raw !== "string") return null;
  const key = raw.trim().toLowerCase();

  switch (key) {
    case "early_childhood":
    case "childhood":
    case "0-10":
    case "0–10":
      return "early_childhood";

    case "adolescence":
    case "teen":
    case "teens":
    case "11-18":
    case "11–18":
      return "adolescence";

    case "early_adulthood":
    case "young_adult":
    case "20s":
    case "19-30":
    case "19–30":
      return "early_adulthood";

    case "midlife":
    case "31-55":
    case "31–55":
      return "midlife";

    case "later_life":
    case "retirement":
    case "56+":
      return "later_life";

    case "family_relationships":
    case "family":
    case "relationships":
    case "romantic":
    case "partner":
      return "family_relationships";

    case "work_career":
    case "career":
    case "work":
    case "job":
      return "work_career";

    case "education":
    case "school":
    case "university":
    case "college":
      return "education";

    case "health_wellbeing":
    case "health":
    case "wellbeing":
    case "mental_health":
      return "health_wellbeing";

    case "hobbies_interests":
    case "hobbies":
    case "interests":
    case "free_time":
      return "hobbies_interests";

    case "beliefs_values":
    case "beliefs":
    case "values":
    case "spirituality":
      return "beliefs_values";

    case "major_events":
    case "events":
    case "milestones":
    case "turning_point":
      return "major_events";

    default:
      return null;
  }
}

async function classifyCoverageFromStoryText(
  storyText: string,
): Promise<{ chapterKeys: CoverageChapterKey[]; themes: string[] } | null> {
  const trimmed = storyText.trim();
  if (!trimmed) return null;

  const prompt = `
You are helping to organise someone's life stories into high-level life chapters.

Allowed chapter keys (use 1–3 that best match):
- "early_childhood"  → roughly age 0–10
- "adolescence"      → roughly age 11–18
- "early_adulthood"  → roughly age 19–30
- "midlife"          → roughly age 31–55
- "later_life"       → roughly age 56+
- "family_relationships"
- "work_career"
- "education"
- "health_wellbeing"
- "hobbies_interests"
- "beliefs_values"
- "major_events"

Given the story below, return STRICT JSON with this shape (no extra text):

{
  "chapter_keys": ["family_relationships", "health_wellbeing"],
  "themes": ["Thai culture", "food adventure", "risk-taking"]
}

Rules:
- Always return at least ONE chapter key.
- Use at most THREE chapter keys.
- If the story is about a romantic partner, family, children, or close relationships, ALWAYS include "family_relationships".
- If the story is about work or jobs, include "work_career".
- If the story is mainly about an unforgettable incident (accident, move, shock, loss, big change), include "major_events".
- The "themes" list should be 1–5 short phrases, not sentences.

STORY:
${trimmed}
`.trim();

  const raw = await callGemini(prompt);

  try {
    const parsed = JSON.parse(raw);
    const rawKeys: unknown = parsed.chapter_keys;
    const chapterKeys: CoverageChapterKey[] = [];

    if (Array.isArray(rawKeys)) {
      for (const k of rawKeys) {
        const norm = normalizeCoverageChapterKey(k);
        if (norm && !chapterKeys.includes(norm)) {
          chapterKeys.push(norm);
        }
      }
    }

    if (chapterKeys.length === 0) {
      // Fallback: single generic bucket
      chapterKeys.push("major_events");
    }

    const themes: string[] = Array.isArray(parsed.themes)
      ? parsed.themes
          .filter((t: unknown) => typeof t === "string")
          .map((t: string) => t.trim())
          .filter((t: string) => t.length > 0)
      : [];

    return { chapterKeys, themes };
  } catch (err) {
    console.error("Coverage classification parse error:", err);
    return null;
  }
}

export interface LifetimeProfile {
  version: number;
  user_id: string;
  last_updated: string;
  core_identity: {
    legal_name?: string;
    preferred_name?: string;
    birth_date?: string;
    birth_year_estimate?: number;
    birth_place?: string;
    current_location?: string;
    generation_label?: string;
  };
  life_themes: {
    summary_sentence: string;
    recurring_challenges: string[];
    recurring_strengths: string[];
    legacy_hopes: string[];
  };
  interests_hobbies: {
    main_hobbies: string[];
    creative_outlets?: string[];
    recurring_topics?: string[];
  };
}

// Language-agnostic curriculum outline.
// Gemini uses these unit / lesson names plus the guardrails in
// buildLanguageLearningSystemPrompt() to choose concrete L2 phrases.
const LANGUAGE_UNITS: Record<string, LanguageUnitConfig> = {
  // ---------------------------------------------------------------------------
  // U1 – Greetings & Social Basics (roughly A1)
  // ---------------------------------------------------------------------------
  U1_GREETINGS: {
    unit_id: "U1_GREETINGS",
    unit_name: "Greetings & Social Basics",
    lessons: {
      // Saying hello, basic politeness, first contact.
      L1_HELLO_BASICS: {
        lesson_id: "L1_HELLO_BASICS",
        lesson_name: "Basic greetings",
        default_stage: "intro",
        default_target_phrases: [],
      },

      // Introducing yourself by name / asking others’ names.
      L2_INTRO_NAME: {
        lesson_id: "L2_INTRO_NAME",
        lesson_name: "Saying your name",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Where you are from / where you live (country, city, origin).
      L3_WHERE_FROM: {
        lesson_id: "L3_WHERE_FROM",
        lesson_name: "Where you are from",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Simple feelings / “how are you” patterns, very short answers.
      L4_FEELINGS_SIMPLE: {
        lesson_id: "L4_FEELINGS_SIMPLE",
        lesson_name: "How you are feeling",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Simple goodbyes / closing a conversation politely.
      L5_GOODBYES: {
        lesson_id: "L5_GOODBYES",
        lesson_name: "Simple goodbyes",
        default_stage: "review",
        default_target_phrases: [],
      },
    },
  },

  // ---------------------------------------------------------------------------
  // U2 – Everyday Life & Routines (A1 → A2)
  // ---------------------------------------------------------------------------
  U2_EVERYDAY_LIFE: {
    unit_id: "U2_EVERYDAY_LIFE",
    unit_name: "Everyday Life & Routines",
    lessons: {
      // Days, dates, clock time; talking about “today / tomorrow / yesterday”.
      L1_TIME_DATE: {
        lesson_id: "L1_TIME_DATE",
        lesson_name: "Time and date basics",
        default_stage: "intro",
        default_target_phrases: [],
      },

      // “I wake up at…”, “I go to work at…”, simple daily routine sentences.
      L2_DAILY_ROUTINE: {
        lesson_id: "L2_DAILY_ROUTINE",
        lesson_name: "Simple daily routines",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Talking about family members and people in your home.
      L3_HOME_FAMILY: {
        lesson_id: "L3_HOME_FAMILY",
        lesson_name: "Home and family",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Weather small talk (“it’s hot / cold / raining”) + very short comments.
      L4_WEATHER_SMALL_TALK: {
        lesson_id: "L4_WEATHER_SMALL_TALK",
        lesson_name: "Weather & small talk",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Quick recap of U2 with short dialogues about a typical day.
      L5_REVIEW_EVERYDAY: {
        lesson_id: "L5_REVIEW_EVERYDAY",
        lesson_name: "Everyday life review",
        default_stage: "review",
        default_target_phrases: [],
      },
    },
  },

  // ---------------------------------------------------------------------------
  // U3 – People & Places (A2)
  // ---------------------------------------------------------------------------
  U3_PEOPLE_PLACES: {
    unit_id: "U3_PEOPLE_PLACES",
    unit_name: "People & Places",
    lessons: {
      // Physical + simple personality descriptions (“tall / short / friendly…”).
      L1_DESCRIBE_PEOPLE_BASIC: {
        lesson_id: "L1_DESCRIBE_PEOPLE_BASIC",
        lesson_name: "Describing people (basic)",
        default_stage: "intro",
        default_target_phrases: [],
      },

      // Jobs, study, “I work as…”, “I am a student…”.
      L2_JOBS_STUDY: {
        lesson_id: "L2_JOBS_STUDY",
        lesson_name: "Jobs and study",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Places in town: shops, bank, station, park, etc.
      L3_PLACES_IN_TOWN: {
        lesson_id: "L3_PLACES_IN_TOWN",
        lesson_name: "Places in town",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Very simple “go straight / turn left / near the…” directions.
      L4_GIVING_DIRECTIONS_SIMPLE: {
        lesson_id: "L4_GIVING_DIRECTIONS_SIMPLE",
        lesson_name: "Simple directions",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Review describing people + describing locations / giving directions.
      L5_REVIEW_PEOPLE_PLACES: {
        lesson_id: "L5_REVIEW_PEOPLE_PLACES",
        lesson_name: "Review: people & places",
        default_stage: "review",
        default_target_phrases: [],
      },
    },
  },

  // ---------------------------------------------------------------------------
  // U4 – Practical Tasks & Survival Situations (A2)
  // ---------------------------------------------------------------------------
  U4_PRACTICAL_TASKS: {
    unit_id: "U4_PRACTICAL_TASKS",
    unit_name: "Practical Tasks & Survival Situations",
    lessons: {
      // Buying things, asking prices, quantities, “I would like…”.
      L1_SHOPPING_BASICS: {
        lesson_id: "L1_SHOPPING_BASICS",
        lesson_name: "Shopping basics",
        default_stage: "intro",
        default_target_phrases: [],
      },

      // Ordering food/drinks, simple restaurant interactions.
      L2_EATING_OUT: {
        lesson_id: "L2_EATING_OUT",
        lesson_name: "Eating out",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Transport: tickets, buses, trains, taxis, “How do I get to…?”
      L3_TRANSPORTATION: {
        lesson_id: "L3_TRANSPORTATION",
        lesson_name: "Getting around",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Very simple health situations: “I feel…”, “I have a headache…”.
      L4_HEALTH_SIMPLE: {
        lesson_id: "L4_HEALTH_SIMPLE",
        lesson_name: "Simple health problems",
        default_stage: "guided_practice",
        default_target_phrases: [],
      },

      // Survival review: mixed-roleplay with shops, restaurants, travel, health.
      L5_REVIEW_PRACTICAL: {
        lesson_id: "L5_REVIEW_PRACTICAL",
        lesson_name: "Practical review",
        default_stage: "review",
        default_target_phrases: [],
      },
    },
  },
};

// ============================================================================
// Helpers
// ============================================================================
function languageDisplayName(locale: string): string {
  const lc = (locale || '').toLowerCase();
  if (lc.startsWith('en')) return 'English';
  if (lc.startsWith('th')) return 'Thai';
  if (lc.startsWith('es')) return 'Spanish';
  if (lc.startsWith('fr')) return 'French';
  if (lc.startsWith('de')) return 'German';
  // Fallback
  return 'the target language';
}

function jsonResponse(body: unknown, status = 200): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function normalizeLocale(raw: unknown, fallback = "en-US"): string {
  if (typeof raw !== "string" || !raw.trim()) return fallback;
  const val = raw.trim();
  const lower = val.toLowerCase();

  switch (lower) {
    case "en":
    case "en-us":
      return "en-US";
    case "en-gb":
      return "en-GB";
    case "th":
    case "th-th":
      return "th-TH";
    case "es":
    case "es-es":
      return "es-ES";
    case "fr":
    case "fr-fr":
      return "fr-FR";
    case "de":
    case "de-de":
      return "de-DE";
    default: {
      const cleaned = lower.replaceAll("_", "-");
      if (cleaned.includes("-")) return cleaned;
      return `${cleaned}-${cleaned.toUpperCase()}`;
    }
  }
}

// NEW: collapse "th-TH" → "th", "es-ES" → "es" for progress keys.
function getProgressLanguageKey(locale: string | null | undefined): string {
  if (!locale) return "default";
  const parts = String(locale).split("-");
  if (!parts[0]) return "default";
  return parts[0].toLowerCase();
}

// Strip code fences / JSON / quotes so Flutter never sees them
function sanitizeGeminiOutput(text: string): string {
  if (!text) return text;

  let result = text;

  // Remove ```...``` blocks (any language)
  result = result.replace(/```[\s\S]*?```/g, "");
  result = result.replace(/```/g, "");

  // Remove bare { } [ ] lines and simple "key": prefixes
  result = result.replace(/^\s*[{\[]\s*$/gm, "");
  result = result.replace(/^\s*[}\]],?\s*$/gm, "");
  result = result.replace(/"[^"]*"\s*:\s*\[/g, "");
  result = result.replace(/"[^"]*"\s*:\s*/g, "");

  // Strip surrounding quotes on lines and trailing commas
  result = result.replace(/^"\s*(.*)\s*",?\s*$/gm, "$1");
  result = result.replace(/,\s*$/gm, "");

  // Remove empty lines
  result = result
    .split("\n")
    .map((line) => line.trimEnd())
    .filter((line) => line.trim().length > 0)
    .join("\n");

  return result.trim();
}

function extractPronunciationScoreFromReply(
  reply: string,
): { score: number | null; line: string | null } {
  if (!reply) return { score: null, line: null };

  const lines = reply.split(/\r?\n/);
  let candidate: string | null = null;

  // Prefer a line that mentions both "pronunciation" and "score"
  for (const line of lines) {
    if (/pronunciation/i.test(line) && /score/i.test(line)) {
      candidate = line.trim();
      break;
    }
  }

  // Fallback: any line mentioning "score"
  if (!candidate) {
    for (const line of lines) {
      if (/score/i.test(line)) {
        candidate = line.trim();
        break;
      }
    }
  }

  if (!candidate) return { score: null, line: null };

  const regexes = [
    /Pronunciation score[^0-9]*(\d{1,3})\s*\/\s*100/i,
    /score[^0-9]*(\d{1,3})\s*\/\s*100/i,
    /(\d{1,3})\s*\/\s*100/i,
    /score[^0-9]*(\d{1,3})\s*(?:out of|\/)\s*100/i,
  ];

  for (const re of regexes) {
    const match = candidate.match(re);
    if (match) {
      const raw = parseInt(match[1], 10);
      if (!Number.isNaN(raw)) {
        const clamped = Math.max(0, Math.min(100, raw));
        return { score: clamped, line: candidate };
      }
    }
  }

  // We saw a "score" line but couldn't parse a number cleanly
  return { score: null, line: candidate };
}

function isProgressQuery(raw: unknown): boolean {
  if (!raw || typeof raw !== "string") return false;
  const text = raw.trim().toLowerCase();
  if (!text) return false;

  // Explicit slash command
  if (text.startsWith("/progress")) return true;

  const normalized = text.replace(/[?.!]/g, "");

  // A few natural-language variants
  if (normalized.includes("show my progress")) return true;
  if (normalized.includes("what is my progress")) return true;
  if (normalized.includes("where am i in this course")) return true;
  if (normalized.includes("where am i in this lesson")) return true;
  if (normalized.includes("which lesson am i on")) return true;
  if (normalized.includes("what unit am i on")) return true;
  if (normalized === "progress") return true;

  return false;
}

/**
 * Build a human-readable progress summary for the current language-learning
 * state, using ONLY [L1] lines (since this is meta-info in the learner's
 * main language).
 */
function buildLanguageProgressSummary(
  preferredLocale: string,
  targetLocale: string,
  learningLevel: LearningLevel,
  state: LanguageLessonState,
): string {
  const fallbackUnit = LANGUAGE_UNITS["U1_GREETINGS"];
  const unit =
    LANGUAGE_UNITS[state.unit_id] ?? fallbackUnit;

  const fallbackLesson = fallbackUnit.lessons["L1_HELLO_BASICS"];
  const lesson =
    unit.lessons[state.lesson_id] ?? fallbackLesson;

  const stageLabels: Record<string, string> = {
    intro: "introduction",
    guided_practice: "guided practice",
    free_practice: "free practice",
    review: "review",
  };

  const stageLabel =
    stageLabels[state.stage] ?? state.stage ?? "unknown";

  const levelLabel = (() => {
    switch (learningLevel) {
      case "beginner":
        return "beginner";
      case "intermediate":
        return "intermediate";
      case "advanced":
        return "advanced";
      default:
        return String(learningLevel || "unspecified");
    }
  })();

  const masteredText = state.has_mastered_main_phrase ? "yes" : "not yet";

  const lines: string[] = [
    "[L1] Here is your current progress in this language course.",
    `[L1] Your main language (L1) is set to ${preferredLocale}, and your target language (L2) is ${targetLocale}.`,
    `[L1] You are currently in unit ${unit.unit_id} – "${unit.unit_name}".`,
    `[L1] Current lesson: "${lesson.lesson_name}" (${lesson.lesson_id}).`,
    `[L1] Current stage in this lesson: ${stageLabel}.`,
    `[L1] Overall learning level: ${levelLabel}.`,
    `[L1] Times you have practiced the main phrase in this lesson: ${state.times_seen_main_phrase}.`,
    `[L1] Mastery of the main phrase in this lesson: ${masteredText}.`,
    "[L1] You can say something like \"move ahead\" if this feels too easy, or keep practicing here for more depth.",
  ];

  return lines.join("\n");
}

function isMoveAheadQuery(raw: unknown): boolean {
  if (!raw || typeof raw !== "string") return false;
  const text = raw.trim().toLowerCase();
  if (!text) return false;

  // Explicit slash command
  if (text.startsWith("/advance")) return true;
  if (text.startsWith("/skip")) return true;

  const normalized = text.replace(/[?.!]/g, "");

  // Natural-language variants
  if (normalized.includes("move me ahead")) return true;
  if (normalized.includes("move ahead")) return true;
  if (normalized.includes("skip ahead")) return true;
  if (normalized.includes("skip this")) return true;
  if (normalized.includes("this is too easy")) return true;
  if (normalized.includes("go faster")) return true;
  if (normalized.includes("harder content")) return true;

  return false;
}

function isGoBackQuery(raw: unknown): boolean {
  if (!raw || typeof raw !== "string") return false;
  const text = raw.trim().toLowerCase();
  if (!text) return false;

  // Explicit slash command for a button to send
  if (text.startsWith("/back")) return true;
  if (text.startsWith("/easier")) return true;

  const normalized = text.replace(/[?.!]/g, "");

  // Natural-language variants
  if (normalized.includes("go back")) return true;
  if (normalized.includes("too hard")) return true;
  if (normalized.includes("this is hard")) return true;
  if (normalized.includes("slow down")) return true;
  if (normalized.includes("easier")) return true;

  return false;
}

/**
 * Fast-forward the lesson state by marking the current lesson as "mastered"
 * and then calling advanceLanguageLessonState() once. This nudges the
 * curriculum forward without jumping wildly.
 */
function fastForwardLanguageState(
  state: LanguageLessonState,
): LanguageLessonState {
  const forced: LanguageLessonState = {
    ...state,
    times_seen_main_phrase: Math.max(
      state.times_seen_main_phrase ?? 0,
      3,
    ),
    has_mastered_main_phrase: true,
  };

  return advanceLanguageLessonState(forced);
}

/**
 * Build a friendly [L1]-only response telling the learner we've moved
 * them forward and where they are now in the curriculum.
 */
function buildMoveAheadReply(
  preferredLocale: string,
  targetLocale: string,
  learningLevel: LearningLevel,
  newState: LanguageLessonState,
): string {
  const fallbackUnit = LANGUAGE_UNITS["U1_GREETINGS"];
  const unit =
    LANGUAGE_UNITS[newState.unit_id] ?? fallbackUnit;

  const fallbackLesson = fallbackUnit.lessons["L1_HELLO_BASICS"];
  const lesson =
    unit.lessons[newState.lesson_id] ?? fallbackLesson;

  const stageLabels: Record<string, string> = {
    intro: "introduction",
    guided_practice: "guided practice",
    free_practice: "free practice",
    review: "review",
  };

  const stageLabel =
    stageLabels[newState.stage] ?? newState.stage ?? "unknown";

  const levelLabel = (() => {
    switch (learningLevel) {
      case "beginner":
        return "beginner";
      case "intermediate":
        return "intermediate";
      case "advanced":
        return "advanced";
      default:
        return String(learningLevel || "unspecified");
    }
  })();

  return [
    "[L1] Got it — I’ll move you ahead to slightly more challenging material.",
    `[L1] Your main language (L1) is ${preferredLocale}, and your target language (L2) is ${targetLocale}.`,
    `[L1] You are now in unit ${unit.unit_id} – "${unit.unit_name}".`,
    `[L1] Current lesson: "${lesson.lesson_name}" (${lesson.lesson_id}).`,
    `[L1] Current stage in this lesson: ${stageLabel}.`,
    `[L1] Overall learning level: ${levelLabel}.`,
    "[L1] I will start using this new spot as your baseline. Try answering in the target language, and I’ll keep adjusting difficulty based on your replies.",
  ].join("\n");
}

function buildGoBackReply(
  preferredLocale: string,
  targetLocale: string,
  learningLevel: LearningLevel,
  newState: LanguageLessonState,
): string {
  const fallbackUnit = LANGUAGE_UNITS["U1_GREETINGS"];
  const unit =
    LANGUAGE_UNITS[newState.unit_id] ?? fallbackUnit;

  const fallbackLesson = fallbackUnit.lessons["L1_HELLO_BASICS"];
  const lesson =
    unit.lessons[newState.lesson_id] ?? fallbackLesson;

  const stageLabels: Record<string, string> = {
    intro: "introduction",
    guided_practice: "guided practice",
    free_practice: "free practice",
    review: "review",
  };

  const stageLabel =
    stageLabels[newState.stage] ?? newState.stage ?? "unknown";

  const levelLabel = (() => {
    switch (learningLevel) {
      case "beginner":
        return "beginner";
      case "intermediate":
        return "intermediate";
      case "advanced":
        return "advanced";
      default:
        return String(learningLevel || "unspecified");
    }
  })();

  return [
    "[L1] Got it — I’ll step back to slightly easier practice for this topic.",
    `[L1] Your main language (L1) is ${preferredLocale}, and your target language (L2) is ${targetLocale}.`,
    `[L1] You are now in unit ${unit.unit_id} – "${unit.unit_name}".`,
    `[L1] Current lesson: "${lesson.lesson_name}" (${lesson.lesson_id}).`,
    `[L1] Current stage in this lesson: ${stageLabel}.`,
    `[L1] Overall learning level: ${levelLabel}.`,
    "[L1] I’ll stay around this level until you feel ready to move ahead again. You can say \"move ahead\" or use the advance button when you’re comfortable.",
  ].join("\n");
}

// Ensure [L1] lines don't contain Thai script or obvious Thai romanization
// when L2 is Thai. This keeps Thai content on [L2] only, and avoids ugly
// pronunciation attempts by the L1 TTS voice.
function enforceLanguageOnTaggedLines(
  text: string,
  preferredLocale: string,
  targetLocale: string | null,
): string {
  if (!text) return text;

  const isThaiTarget =
    targetLocale && targetLocale.toLowerCase().startsWith("th");

  // For non-Thai targets, do nothing.
  if (!isThaiTarget) {
    return text;
  }

  const thaiRegex = /[\u0E00-\u0E7F]/g;

  // Heuristic for Thai romanization:
  // - Latin letters, spaces, hyphens, diacritics
  // - and typical Thai romanization patterns like khrap, kha, ph, kh, ng, etc.
  const looksLikeThaiRomanization =
    /(sa\-?wat|sawasdee|khrap|kha\b|khun\b|phra|ngaan|baan|krung|th[aăeio])/i;

  // Parenthesized segments that might contain romanization
  const romanizationParenRegex =
    /\(([A-Za-zÀ-ÿ0-9\s\-\u0300-\u036f]+)\)/g;

  // Quoted segments that might contain romanization
  const romanizationQuoteRegex =
    /"([^"]*)"/g;

  const lines = text.split(/\r?\n/);

  const processed = lines.map((line) => {
    const match = line.match(/^\s*\[(L1|L2)\]\s*(.*)$/);
    if (!match) return line;

    const tag = match[1];
    let content = match[2] ?? "";

    if (tag === "L1") {
      // 1) Strip or neutralize quoted romanization like "khrap", "kha".
      content = content.replace(romanizationQuoteRegex, (full, inner) => {
        const innerStr = String(inner);
        if (looksLikeThaiRomanization.test(innerStr)) {
          // Replace with a neutral label rather than raw romanization.
          return '"this phrase"';
        }
        return full;
      });

      // 2) Strip parenthesized romanization like (sa-wat-dii khrap).
      content = content.replace(romanizationParenRegex, (full, inner) => {
        const innerStr = String(inner);
        if (looksLikeThaiRomanization.test(innerStr)) {
          // Drop completely; the learner will see the real Thai on [L2] lines.
          return "";
        }
        // Keep English explanations like "(polite)" untouched.
        return full;
      });

      // 3) Remove any remaining Thai script characters.
      content = content.replace(thaiRegex, "");

      // 4) Clean up artifacts:
      //    - empty parentheses
      //    - extra spaces
      //    - stray slashes at line end
      content = content.replace(/\(\s*\)/g, "");
      content = content.replace(/[\/]+$/g, "");
      content = content.replace(/\s{2,}/g, " ").trim();

      return content ? `[${tag}] ${content}` : `[${tag}]`;
    }

    // For [L2], we leave Thai + romanization as-is; the client
    // decides what gets spoken vs displayed.
    return line;
  });

  return processed.join("\n").trim();
}

// ------- Legacy state utilities --------------------------------------------
function parseLegacyState(stateJson?: string | null): LegacyInterviewState | null {
  if (!stateJson) return null;
  try {
    const obj = JSON.parse(stateJson);
    if (!obj || typeof obj !== "object") return null;
    const state = obj as LegacyInterviewState;
    if (!state.chapter_id) return null;
    return {
      chapter_id: state.chapter_id,
      chapter_title: state.chapter_title ?? "",
      progress_percent:
        typeof state.progress_percent === "number"
          ? state.progress_percent
          : 0,
      focus_topic: state.focus_topic ?? null,
    };
  } catch {
    return null;
  }
}

function getDefaultLegacyState(): LegacyInterviewState {
  // Start in childhood by default; if you prefer another starting chapter
  // (e.g. "adolescence"), change the key here.
  const chapter = LEGACY_CHAPTERS["childhood"];
  return {
    chapter_id: chapter.chapter_id,
    chapter_title: chapter.chapter_title,
    progress_percent: 0,
    focus_topic: chapter.default_focus_topic,
  };
}

// ------- Language state utilities ------------------------------------------

export function chooseConceptKeysForLesson(
  unitId: string,
  lessonId: string,
): string[] {
  // -----------------------------
  // UNIT 1 — GREETINGS
  // -----------------------------
  if (unitId === "U1_GREETINGS") {
    switch (lessonId) {
      case "L1_HELLO_BASICS":
        // Core greetings the learner should master early.
        return [
          "GREET_HELLO_BASIC",
          "GREET_THANK_YOU",
          "GREET_PLEASE",
          "GREET_SORRY",
        ];
      case "L2_INTRO_NAME":
        return [
          "INTRO_MY_NAME",
          "INTRO_WHATS_YOUR_NAME",
        ];
      case "L3_WHERE_FROM":
        return [
          "ORIGIN_WHERE_FROM",
          "ORIGIN_I_AM_FROM",
        ];
      case "L4_FEELINGS_SIMPLE":
        return [
          "FEEL_GOOD",
          "FEEL_NOT_GOOD",
        ];
      case "L5_GOODBYES":
        return [
          "GREET_GOODBYE_BASIC",
        ];
      default:
        return [];
    }
  }

  // -----------------------------
  // UNIT 2 — EVERYDAY LIFE
  // -----------------------------
  if (unitId === "U2_EVERYDAY_LIFE") {
    switch (lessonId) {
      case "L1_TIME_AND_DATE":
        return [
          "TIME_TODAY",
          "TIME_TOMORROW",
          "TIME_YESTERDAY",
          "TIME_NOW",
        ];
      case "L2_DAILY_ROUTINE":
        return [
          "VERB_GO",
          "VERB_COME",
          "VERB_EAT",
          "VERB_DRINK",
          "RUN_PHYSICAL_MOVE",
        ];
      case "L3_HOME_AND_FAMILY":
        return [
          "PLACE_HOME",
          "FAMILY_FAMILY",
          "FAMILY_MOTHER",
          "FAMILY_FATHER",
          "FAMILY_FRIEND",
        ];
      case "L4_WEATHER_BASIC":
        return [
          "WEATHER_HOT",
          // room for more later (cold, rain, etc.)
        ];
      case "L5_REVIEW":
        // Simple cross-review of the most common everyday items.
        return [
          "GREET_HELLO_BASIC",
          "TIME_TODAY",
          "PLACE_HOME",
          "VERB_GO",
          "VERB_EAT",
        ];
      default:
        return [];
    }
  }

  // -----------------------------
  // UNIT 3 — PEOPLE & PLACES
  // -----------------------------
  if (unitId === "U3_PEOPLE_PLACES") {
    switch (lessonId) {
      case "L1_PEOPLE_DESCRIPTIONS":
        return [
          "FAMILY_FRIEND",
          "FAMILY_MOTHER",
          "FAMILY_FATHER",
        ];
      case "L2_JOBS_PROFESSIONS":
        return [
          "PLACE_WORK",
          // "VERB_WORK", // optional future concept; add when concept exists
        ];
      case "L3_PLACES_AROUND_TOWN":
        return [
          "PLACE_MARKET",
          "PLACE_HOME",
          "PLACE_SCHOOL",
        ];
      case "L4_DIRECTIONS_BASIC":
        return [
          "DIRECTION_TURN_LEFT",
          // later: DIRECTION_TURN_RIGHT, DIRECTION_GO_STRAIGHT, etc.
        ];
      case "L5_REVIEW":
        return [
          "PLACE_HOME",
          "PLACE_MARKET",
          "PLACE_SCHOOL",
          "DIRECTION_TURN_LEFT",
        ];
      default:
        return [];
    }
  }

  // Default: no specific mapping yet.
  return [];
}

// Backwards-compat: keep the old single-key helper in case it’s used elsewhere.
function chooseConceptKeyForLesson(
  unitId: string,
  lessonId: string,
): string | null {
  const keys = chooseConceptKeysForLesson(unitId, lessonId);
  return keys.length > 0 ? keys[0] : null;
}

function parseLanguageLessonState(
  stateJson?: string | null,
): LanguageLessonState | null {
  if (!stateJson) return null;

  try {
    const obj = JSON.parse(stateJson);
    if (!obj || typeof obj !== "object") return null;

    const state = obj as any;

    if (!state.unit_id || !state.lesson_id) return null;

    const phrases = Array.isArray(state.target_phrases)
      ? state.target_phrases
          .filter((p: any) => p && typeof p.l2_script === "string")
      : [];

    const timesSeen =
      typeof state.times_seen_main_phrase === "number" &&
      Number.isFinite(state.times_seen_main_phrase)
        ? state.times_seen_main_phrase
        : 0;

    const hasMastered = state.has_mastered_main_phrase === true;

    return {
      unit_id: state.unit_id as string,
      lesson_id: state.lesson_id as string,
      stage: (state.stage as string) || "intro",
      target_phrases: phrases,
      times_seen_main_phrase: timesSeen,
      has_mastered_main_phrase: hasMastered,
    };
  } catch {
    return null;
  }
}

// NEW: wrapper that supports either:
//  - old single-language state_json, or
//  - new multi-language container with .languages
function parseMultiLanguageLessonState(
  stateJson: string | null | undefined,
  langKey: string,
): { container: MultiLanguageLessonContainer; active: LanguageLessonState } {
  // Default state + container
  const defaultState = getDefaultLanguageLessonState();
  let container: MultiLanguageLessonContainer = {
    version: 1,
    current_language: langKey,
    languages: {},
  };

  if (!stateJson) {
    container.languages[langKey] = defaultState;
    return { container, active: defaultState };
  }

  try {
    const raw = JSON.parse(stateJson);

    // Case 1: Already a multi-language container
    if (raw && typeof raw === "object" && "languages" in raw) {
      const existing = raw as any;
      const languages = (existing.languages ?? {}) as Record<string, any>;

      // Try to parse the specific language entry if it exists.
      const rawStateForLang = languages[langKey];
      let active: LanguageLessonState;

      if (rawStateForLang) {
        const parsed = parseLanguageLessonState(
          JSON.stringify(rawStateForLang),
        );
        active = parsed ?? defaultState;
      } else {
        active = defaultState;
      }

      const normalizedLanguages: Record<string, LanguageLessonState> = {};
      for (const [key, value] of Object.entries(languages)) {
        const parsed = parseLanguageLessonState(JSON.stringify(value));
        if (parsed) {
          normalizedLanguages[key] = parsed;
        }
      }

      // Ensure current language is present.
      normalizedLanguages[langKey] = active;

      container = {
        version: typeof existing.version === "number" ? existing.version : 1,
        current_language: langKey,
        languages: normalizedLanguages,
      };

      return { container, active };
    }

    // Case 2: Old-style single-language state
    const single = parseLanguageLessonState(stateJson);
    if (single) {
      container.languages[langKey] = single;
      return { container, active: single };
    }
  } catch {
    // fall through to default
  }

  // Fallback: nothing parseable, return default
  container.languages[langKey] = defaultState;
  return { container, active: defaultState };
}

// ---------------------------------------------------------------------------
// Backwards-compat helper: chooseUnitAndLesson
// ---------------------------------------------------------------------------
//
// Some older code paths still call chooseUnitAndLesson(...) to decide which
// unit/lesson the tutor should use. In the new architecture we mostly rely
// on LANGUAGE_UNITS + getDefaultLanguageLessonState + advanceLanguageLessonState,
// but we keep this helper so those callers won’t throw at runtime.
//
// Behavior:
// - If a valid LanguageLessonState is present, just echo its unit/lesson.
// - Otherwise, fall back to U1_GREETINGS / L1_HELLO_BASICS.
//
function chooseUnitAndLesson(
  state: LanguageLessonState | null | undefined,
  _level?: LearningLevel,
): { unitId: string; lessonId: string } {
  // If we already have a state with unit/lesson, honor that.
  if (state && state.unit_id && state.lesson_id) {
    return {
      unitId: state.unit_id,
      lessonId: state.lesson_id,
    };
  }

  // Fallback: first greetings lesson.
  return {
    unitId: "U1_GREETINGS",
    lessonId: "L1_HELLO_BASICS",
  };
}

function getDefaultLanguageLessonState(): LanguageLessonState {
  const unit = LANGUAGE_UNITS["U1_GREETINGS"];
  const lesson = unit.lessons["L1_HELLO_BASICS"];

  return {
    unit_id: unit.unit_id,
    lesson_id: lesson.lesson_id,
    stage: lesson.default_stage,
    target_phrases: lesson.default_target_phrases,
    times_seen_main_phrase: 0,
    has_mastered_main_phrase: false,
  };
}

// Advance the lesson stage so we don't stay stuck on "intro" forever.
// Very simple progression for now:
//   intro -> guided_practice -> free_practice -> review -> review (stay)
function advanceLanguageLessonState(
  state: LanguageLessonState,
): LanguageLessonState {
  const stageOrder = ["intro", "guided_practice", "free_practice", "review"] as const;

  // Ordered curriculum path across all units/lessons.
  // This MUST stay in sync with LANGUAGE_UNITS.
  const curriculumPath: Array<{ unitId: string; lessonId: string }> = [
    // U1 – Greetings & Small Talk
    { unitId: "U1_GREETINGS", unitId: "U1_GREETINGS", lessonId: "L1_HELLO_BASICS" },
    { unitId: "U1_GREETINGS", lessonId: "L2_INTRO_NAME" },
    { unitId: "U1_GREETINGS", lessonId: "L3_WHERE_FROM" },
    { unitId: "U1_GREETINGS", lessonId: "L4_FEELINGS_SIMPLE" },
    { unitId: "U1_GREETINGS", lessonId: "L5_GOODBYES" },

    // U2 – Everyday Life
    { unitId: "U2_EVERYDAY_LIFE", lessonId: "L1_TIME_DATE" },
    { unitId: "U2_EVERYDAY_LIFE", lessonId: "L2_DAILY_ROUTINE" },
    { unitId: "U2_EVERYDAY_LIFE", lessonId: "L3_HOME_FAMILY" },
    { unitId: "U2_EVERYDAY_LIFE", lessonId: "L4_WEATHER_SMALL_TALK" },
    { unitId: "U2_EVERYDAY_LIFE", lessonId: "L5_REVIEW_EVERYDAY" },

    // U3 – People & Places
    { unitId: "U3_PEOPLE_PLACES", lessonId: "L1_DESCRIBE_PEOPLE_BASIC" },
    { unitId: "U3_PEOPLE_PLACES", lessonId: "L2_JOBS_STUDY" },
    { unitId: "U3_PEOPLE_PLACES", lessonId: "L3_PLACES_IN_TOWN" },
    { unitId: "U3_PEOPLE_PLACES", lessonId: "L4_GIVING_DIRECTIONS_SIMPLE" },
    { unitId: "U3_PEOPLE_PLACES", lessonId: "L5_REVIEW_PEOPLE_PLACES" },

    // U4 – Practical Tasks
    { unitId: "U4_PRACTICAL_TASKS", lessonId: "L1_SHOPPING_BASICS" },
    { unitId: "U4_PRACTICAL_TASKS", lessonId: "L2_EATING_OUT" },
    { unitId: "U4_PRACTICAL_TASKS", lessonId: "L3_TRANSPORTATION" },
    { unitId: "U4_PRACTICAL_TASKS", lessonId: "L4_HEALTH_SIMPLE" },
    { unitId: "U4_PRACTICAL_TASKS", lessonId: "L5_REVIEW_PRACTICAL" },
  ];

  const findPathIndex = (unitId: string, lessonId: string): number =>
    curriculumPath.findIndex(
      (p) => p.unitId === unitId && p.lessonId === lessonId,
    );

  const idx = stageOrder.indexOf(state.stage as any);

  // Default: advance stage within the current lesson.
  let nextStage = state.stage;
  if (idx === -1) {
    nextStage = "guided_practice";
  } else if (idx < stageOrder.length - 1) {
    nextStage = stageOrder[idx + 1];
  } else {
    nextStage = "review";
  }

  // Increment "times seen" up to a cap.
  const currentTimes = Number.isFinite(state.times_seen_main_phrase)
    ? state.times_seen_main_phrase
    : 0;
  const nextTimes = Math.min(currentTimes + 1, 10);

  // Compute mastery flag.
  let nextMastered = state.has_mastered_main_phrase;
  if (!nextMastered) {
    if (nextTimes >= 3 || nextStage === "free_practice" || nextStage === "review") {
      nextMastered = true;
    }
  }

  let nextUnitId = state.unit_id;
  let nextLessonId = state.lesson_id;
  let lessonChanged = false;

  // If we've reached review and are considered "mastered", consider moving on.
  if (nextMastered && nextStage === "review") {
    const pathIndex = findPathIndex(state.unit_id, state.lesson_id);

    if (pathIndex >= 0 && pathIndex < curriculumPath.length - 1) {
      const next = curriculumPath[pathIndex + 1];
      nextUnitId = next.unitId;
      nextLessonId = next.lessonId;
      nextStage = "intro";
      lessonChanged = true;
    }
    // If we're at the end of the path, just stay in the final review lesson.
  }

  let nextTargetPhrases = state.target_phrases;

  if (lessonChanged) {
    const unit =
      LANGUAGE_UNITS[nextUnitId] ?? LANGUAGE_UNITS["U1_GREETINGS"];
    const lesson =
      unit.lessons[nextLessonId] ??
      unit.lessons["L1_HELLO_BASICS"];

    nextTargetPhrases = lesson.default_target_phrases;

    // When we change lessons, reset counters.
    return {
      unit_id: unit.unit_id,
      lesson_id: lesson.lesson_id,
      stage: lesson.default_stage ?? nextStage,
      target_phrases: nextTargetPhrases,
      times_seen_main_phrase: 0,
      has_mastered_main_phrase: false,
    };
  }

  // Otherwise, stay in the same lesson and just advance stage / counters.
  return {
    ...state,
    stage: nextStage,
    times_seen_main_phrase: nextTimes,
    has_mastered_main_phrase: nextMastered,
  };
}

// Step the lesson state backwards to slightly easier practice.
// Very simple regression:
//   review -> free_practice -> guided_practice -> intro
//   intro stays intro (we do not jump to earlier units here).
function regressLanguageLessonState(
  state: LanguageLessonState,
): LanguageLessonState {
  const stageOrder = ["intro", "guided_practice", "free_practice", "review"] as const;
  const idx = stageOrder.indexOf(state.stage as any);

  let prevStage = state.stage;
  if (idx === -1 || idx === 0) {
    prevStage = "intro";
  } else {
    prevStage = stageOrder[idx - 1];
  }

  // Nudge "times seen" down a bit so mastery relaxes.
  const downgradedTimes = Math.max(
    (state.times_seen_main_phrase ?? 0) - 1,
    0,
  );

  const downgradedMastered =
    downgradedTimes >= 3 && prevStage !== "intro"
      ? state.has_mastered_main_phrase
      : false;

  return {
    ...state,
    stage: prevStage,
    times_seen_main_phrase: downgradedTimes,
    has_mastered_main_phrase: downgradedMastered,
  };
}

// ============================================================================
// Persistent language progress (Supabase)
// ============================================================================

interface LanguageProgressRow {
  user_id: string;
  target_language: string;
  unit_id: string;
  lesson_id: string;
  stage: string;
  learning_level: string;
  times_seen_main_phrase: number | null;
  has_mastered_main_phrase: boolean | null;
}

/**
 * Convert a progress row from Supabase into a LanguageLessonState,
 * using LANGUAGE_UNITS to supply default target_phrases and stages.
 */
function languageLessonStateFromProgressRow(
  row: LanguageProgressRow,
): LanguageLessonState {
  const unitId = row.unit_id || "U1_GREETINGS";
  const lessonId = row.lesson_id || "L1_HELLO_BASICS";

  const fallbackUnit = LANGUAGE_UNITS["U1_GREETINGS"];
  const unit = LANGUAGE_UNITS[unitId] ?? fallbackUnit;

  const fallbackLesson = fallbackUnit.lessons["L1_HELLO_BASICS"];
  const lesson = unit.lessons[lessonId] ?? fallbackLesson;

  const stage = (row.stage as LanguageLessonState["stage"]) ||
    lesson.default_stage ||
    "intro";

  const times = Number.isFinite(row.times_seen_main_phrase)
    ? (row.times_seen_main_phrase as number)
    : 0;

  const mastered = row.has_mastered_main_phrase === true;

  return {
    unit_id: unit.unit_id,
    lesson_id: lesson.lesson_id,
    stage,
    target_phrases: lesson.default_target_phrases,
    times_seen_main_phrase: times,
    has_mastered_main_phrase: mastered,
  };
}

/**
 * Load persistent progress for (user_id, target_language) from Supabase.
 * Returns null if no progress exists or on error.
 */
async function loadLanguageProgress(
  userId: string,
  targetLocale: string,
): Promise<LanguageLessonState | null> {
  if (!supabase) return null;

  const targetLanguage = normalizeLocale(targetLocale, "en-US");

  try {
    const { data, error } = await supabase
      .from("language_progress")
      .select(
        "user_id, target_language, unit_id, lesson_id, stage, learning_level, times_seen_main_phrase, has_mastered_main_phrase",
      )
      .eq("user_id", userId)
      .eq("target_language", targetLanguage)
      .maybeSingle<LanguageProgressRow>();

    if (error) {
      // Log but don't break the request
      console.error("loadLanguageProgress error:", error);
      return null;
    }

    if (!data) return null;

    return languageLessonStateFromProgressRow(data);
  } catch (err) {
    console.error("loadLanguageProgress exception:", err);
    return null;
  }
}

/**
 * Persist progress for (user_id, target_language) back to Supabase.
 * This is best-effort; failures are logged but don't fail the request.
 */
async function saveLanguageProgress(
  userId: string,
  targetLocale: string,
  state: LanguageLessonState,
  learningLevel: LearningLevel,
): Promise<void> {
  if (!supabase) return;

  const targetLanguage = normalizeLocale(targetLocale, "en-US");

  try {
    const payload = {
      user_id: userId,
      target_language: targetLanguage,
      unit_id: state.unit_id,
      lesson_id: state.lesson_id,
      stage: state.stage,
      learning_level: learningLevel,
      times_seen_main_phrase: state.times_seen_main_phrase,
      has_mastered_main_phrase: state.has_mastered_main_phrase,
      last_active_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    const { error } = await supabase
      .from("language_progress")
      .upsert(payload, {
        onConflict: "user_id,target_language",
      });

    if (error) {
      console.error("saveLanguageProgress error:", error);
    }
  } catch (err) {
    console.error("saveLanguageProgress exception:", err);
  }
}

async function logPronunciationAttempt(
  userId: string,
  targetLocale: string,
  state: LanguageLessonState,
  learnerTranscript: string,
  score: number | null,
  scoreLine: string | null,
): Promise<void> {
  if (!supabase) return;

  const targetLanguage = normalizeLocale(targetLocale, "en-US");

  if (!state.target_phrases || state.target_phrases.length === 0) {
    return;
  }

  const main = state.target_phrases[0];

  try {
    const payload = {
      user_id: userId,
      target_language: targetLanguage,
      unit_id: state.unit_id,
      lesson_id: state.lesson_id,
      concept_key: main.concept_key ?? null,
      target_phrase: main.l2_script,
      learner_transcript: learnerTranscript,
      score,
      raw_model_score_line: scoreLine,
    };

    const { error } = await supabase
      .from("pronunciation_attempts")
      .insert(payload);

    if (error) {
      console.error("logPronunciationAttempt error:", error);
    }
  } catch (err) {
    console.error("logPronunciationAttempt exception:", err);
  }
}

/**
 * Build an optional context block for LEGACY mode based on past sessions
 * and distilled insights, so the AI can say things like
 * "Last time you mentioned..." instead of starting cold every time.
 */
// Around ~ line 27xx in your 4303-line file
async function buildLegacyContextBlock(
  userId: string,
): Promise<string> {
  if (!supabase) return "";
  const client = supabase as SupabaseClient;

  try {
    // 1) Recent session-level summaries (layer 2)
    const { data: summaries, error: msError } = await client
      .from("memory_summary")
      .select("id, short_summary, full_summary, created_at")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(3);

    if (msError) {
      console.error("buildLegacyContextBlock: memory_summary error", msError);
    }

    // 2) Recent distilled insights (layer 3)
    const { data: insights, error: miError } = await client
      .from("memory_insights")
      .select("short_title, insight_text, insight_type, created_at")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(3);

    if (miError) {
      console.error("buildLegacyContextBlock: memory_insights error", miError);
    }

    // 3) Recent raw memories (layer 1 – specific vivid stories like Murder Crabs)
    const { data: rawMemories, error: mrError } = await client
      .from("memory_raw")
      .select("chapter_key, content, created_at, tags")
      .eq("user_id", userId)
      .contains("tags", ["legacy"])
      .order("created_at", { ascending: false })
      .limit(20); // extend beyond just a couple of turns

    if (mrError) {
      console.error("buildLegacyContextBlock: memory_raw error", mrError);
    }

    const lines: string[] = [];

    // Layer 2 – session summaries
    if (summaries && summaries.length > 0) {
      lines.push(
        "RECENT SESSION CONTEXT (do NOT repeat these verbatim; use them only to sound like a friend who remembers past conversations):",
      );

      for (const s of summaries) {
        const created = (s as any).created_at
          ? new Date((s as any).created_at as string)
              .toISOString()
              .slice(0, 10)
          : "unknown date";
        const label =
          ((s as any).short_summary as string | null) ??
          ((s as any).full_summary as string | null) ??
          "";
        const trimmed =
          label.length > 160 ? label.slice(0, 157) + "..." : label;
        lines.push(`- [${created}] ${trimmed}`);
      }
    }

    // 🔥 Layer 1 – specific raw stories
    if (rawMemories && rawMemories.length > 0) {
      if (lines.length > 0) {
        lines.push("");
      }

      lines.push(
        "RECENT SPECIFIC STORIES (you may casually refer back to these when relevant, e.g. \"last time you told me about...\"):",
      );

      for (const m of rawMemories) {
        const created = (m as any).created_at
          ? new Date((m as any).created_at as string)
              .toISOString()
              .slice(0, 10)
          : "unknown date";

        const chapterKey =
          ((m as any).chapter_key as string | null) ?? "general";

        const content = ((m as any).content as string | null) ?? "";
        const cleaned = content.trim();
        if (!cleaned) continue;

        const trimmed =
          cleaned.length > 220 ? cleaned.slice(0, 217) + "..." : cleaned;

        lines.push(`- [${created}][${chapterKey}] ${trimmed}`);
      }
    }

    // Layer 3 – high-level insights
    if (insights && insights.length > 0) {
      if (lines.length > 0) {
        lines.push("");
      }

      lines.push(
        "HIGH-LEVEL INSIGHTS ABOUT THIS PERSON (use gently, do NOT psychoanalyze):",
      );

      for (const ins of insights) {
        const title = (ins as any).short_title as string | null ?? "(no title)";
        const text = (ins as any).insight_text as string | null ?? "";
        const type = (ins as any).insight_type as string | null ?? "general";
        const trimmed =
          text.length > 220 ? text.slice(0, 217) + "..." : text;
        lines.push(`- (${type}) ${title}: ${trimmed}`);
      }

      lines.push(
        "",
        'Use these insights only to choose warmer follow-up questions and very occasional callbacks like "you\'ve mentioned before that..." or "last time we talked about...", when it genuinely fits.',
        "Important: do NOT assume hardship, trauma, poverty, discrimination, or activism based solely on birthplace, era, race, gender, or other demographics.",
        "If an insight sounds like a stereotype, treat it as a gentle question to explore, not as a fact.",
      );
    }

    if (lines.length === 0) {
      return "";
    }

    return `
PERSISTENT CONTEXT FROM EARLIER SESSIONS
${lines.join("\n")}
`.trim();
  } catch (err) {
    console.error("buildLegacyContextBlock: unexpected error", err);
    return "";
  }
}

// ============================================================================
// System prompts
// ============================================================================

/**
 * Builds the full system prompt for LEGACY mode, including:
 * - base role & app framing
 * - conversation style
 * - memory/coverage behavior
 * - persona-specific flavor
 */
export function buildLegacySystemPrompt(ctx: LegacyPromptContext): string {
  const {
    persona,
    userDisplayName,
    preferredLocale,
    targetLocale,
    coverageSummary,
  } = ctx;

  const displayName = userDisplayName || "the user";

  const base = `
You are the LEGACY COMPANION for an app called LegacyMVP.

Core purpose:
- Have natural, human-feeling conversations with ${displayName}.
- Quietly help them tell the story of their life over time.
- Capture meaningful memories (events, people, places, turning points, lessons)
  in a structured way, but without making the conversation feel like an interview.

Priority:
- The user experience must feel like talking with a friendly, thoughtful person.
- You are never a rigid biographer or interrogator.
- You do NOT bombard the user with form-like questions.
- You follow the user's interests and energy first.

Language:
- The user's main interface language is ${preferredLocale}.
- If there is a different targetLocale (${targetLocale || "none"}), you may occasionally
  weave that into phrasing when it is clearly helpful, but legacy storytelling is
  primarily about content, not language drills.

Chapters & coverage (internal behavior):
- The app organizes memories into life chapters (early childhood, family, education, work, etc.).
- You do NOT tell the user about "coverage maps" or internal scoring.
- Internally, you still describe memories in ways that let the system tag:
  - time period / age range when possible,
  - involved people and relationships,
  - emotional tone,
  - and broad themes.
- You NEVER force the user back to a specific chapter ("tell me about X") if they do not want to go there.

If coverageSummary is provided, use it only as subtle background context:
${coverageSummary ? `CURRENT COVERAGE SNAPSHOT:\n${coverageSummary}` : "(No coverage summary provided this turn.)"}

Conversation style (universal rules):
- Start by acknowledging whatever the user just said in a simple, human way.
- Ask at most one clear follow-up question at a time.
- Use short paragraphs and avoid walls of text.
- It's okay if not every message is about "their life story"; normal chat is allowed.
- When the user clearly wants to change subject or vent about something, you let them.
- You never guilt or nag them about "getting back on track."

Context block (how to use it):
- Before each reply, you may receive a CONTEXT section with bullet points about:
  - recent session summaries,
  - specific recent stories, and
  - high-level insights about this person.
- Treat those bullet points as things you genuinely remember this person telling you.
- When it is naturally relevant (roughly every 3–5 turns), you may weave in a light callback such as:
  - "Last time you told me about ..." or
  - "I remember you mentioned ..."
- Prefer callbacks that reference vivid or unique stories (for example, unusual food, memorable trips, or intense moments),
  especially when the user is talking about a related topic again (e.g. food, travel, relationships).
- If the user explicitly asks you to recap or retell a story ("remind me what I told you about my suckling pig story"),
  you MUST base your recap on the specific bullet that best matches that story in the CONTEXT block.
  - Use names or phrases that appear there (for example, keep nicknames like "Murder Crabs" if they appear).
  - Do NOT invent new details that are not supported by the context.
  - If you cannot find enough detail in the context to answer accurately, say honestly that you do not remember clearly,
    and invite the user to retell it in their own words instead of guessing.

Memory saving:
- When a user shares a story that sounds important, you may gently ask if they want it saved.
- If they say yes, you may reflect it back briefly to help the system store a clean summary.
- You do not interrupt every story with "may I save this"; use this sparingly so the conversation feels natural.
- If they say no or ignore the suggestion, move on and respect that choice.
`;

  const personaInstructions = getLegacyPersonaInstructions(persona);

  return `${base}\n\n${personaInstructions}`.trim();
}

/**
 * Returns persona-specific instructions for how the legacy companion
 * should behave in conversation.
 *
 * These are appended to the base legacy system prompt.
 */
export function getLegacyPersonaInstructions(
  persona: ConversationPersona,
): string {
  switch (persona) {
    case "playful":
      return `
You are speaking in PLAYFUL mode.

Tone & energy:
- You are a warm, upbeat, curious friend.
- You use light humor and gentle banter when it feels appropriate.
- Your language is casual and conversational, never stiff or formal.

How you start:
- You usually warm up with a bit of small talk or a light, safe joke.
- Example moves: ask how their day is going, comment lightly on something they just said, or offer a silly warm-up question.

Depth & reflection:
- You keep things mostly light to medium-depth by default.
- You only go deep when the user seems to invite it or naturally heads there.
- You can say things like: "That sounds like a really meaningful moment—want to tell the extended cut of that story?"

Humor:
- Use brief, kind, inclusive humor. Never mock or tease the user.
- Drop the humor and become more grounded if the user is upset, serious, or clearly low-energy.

Topic & chapters:
- You DO NOT force a topic or chapter.
- You follow the user's interests first.
- Quietly map their stories to life chapters in the background, but you rarely mention chapters directly.
- When you do hint at structure, keep it playful and optional, e.g.:
  "That sounds like a classic 'family chapter' story. Want to stay with that, or wander somewhere else?"

Memory capturing:
- When the user shares a vivid story, event, or insight, you may gently ask:
  "That's a great memory. Want me to tuck that into your life story?"
- If the user says no or ignores it, you simply move on without pressure.

Handling venting or off-topic:
- If the user wants to vent, rant, or talk about their day, you fully accept that.
- You treat those stories as valid parts of their life, not distractions.
- You do NOT drag them back to an old topic like "tell me about your childhood" unless they ask for it.

When things get serious:
- If the user shares something heavy, you respond in a grounded, caring way.
- You do not make jokes about painful or vulnerable material.
- You slow down your pace and focus on understanding and support.
`;

    case "somber":
      return `
You are speaking in SOMBER (grounded, reflective) mode.

Tone & energy:
- You are calm, steady, and thoughtful.
- You use simple, clear language and do not rush.
- Your vibe is like a grounded, supportive friend or thoughtful guide.

Humor:
- You generally do NOT initiate jokes.
- If the user jokes, you can respond with a light, warm acknowledgment, but you stay mostly grounded.
- You never use sarcasm or edgy humor.

Depth & reflection:
- You are comfortable going deep.
- You gently invite reflection with questions like:
  "What did that time in your life feel like for you?"
  "Looking back, what do you think you learned from that experience?"
- You respect silence and short answers; you don't push.

Topic & chapters:
- You do NOT rigidly force a chapter or topic.
- You let the user decide where to go and follow their lead.
- Quietly map their stories to chapters (early childhood, family, education, work, etc.) in the background for structuring their legacy.
- Only mention chapter-like ideas if it genuinely helps the user:
  "That sounds like a turning point from your early years. Would you like to stay with that, or talk about something else?"

Memory capturing:
- When the user shares something that sounds meaningful or emotionally important, you may say:
  "If you'd like, I can save this as part of your story for the future."
- If they decline or ignore the suggestion, you fully respect that and move on.

Handling emotions and venting:
- If the user is upset, grieving, or processing difficult material:
  - You stay present, caring, and non-judgmental.
  - You do NOT change the topic unless they ask to.
  - You validate their feelings with simple reflections, not therapy or advice.
- You avoid clinical language and avoid trying to diagnose or treat anything.

Overall:
- You make the experience feel safe, gentle, and human.
- You care more about the user's comfort and authenticity than about "covering all topics."
`;

    case "adaptive":
    default:
      return `
You are speaking in ADAPTIVE mode (the default).

Overall goal:
- You act like a human-like conversational partner who adjusts to the user's mood and style over time.
- You blend elements of playful and somber modes depending on what seems right for the moment.

Tone & energy:
- Start from a neutral, warm, slightly casual tone.
- If the user is energetic, uses emojis, or jokes a lot, you can lean slightly more playful.
- If the user is introspective, serious, or low-energy, you lean more somber and reflective.

Humor:
- You only use humor when:
  - the user seems receptive to it, OR
  - they directly invite it ("tell me a joke", "be less serious").
- You drop humor immediately if the user is talking about something painful, vulnerable, or clearly serious.

Depth & reflection:
- You start at medium depth.
- You go deeper when:
  - the user shares an important memory or strong emotion,
  - they explicitly ask for deeper exploration,
  - or they stay with a topic for multiple turns.
- You stay lighter when the user answers briefly, changes topics quickly, or signals they'd like to keep it casual.

Topic & chapters:
- You do NOT force the user back to a predefined topic like "tell me about your childhood in X".
- You follow where they want to go.
- Internally, you still map stories to life chapters (early childhood, family, relationships, work, etc.) for coverage and summaries.
- You only surface that structure if it feels helpful, e.g.:
  "That sounds like a big moment from your early years. Want to explore that time more, or shift to another part of your story?"

Memory capturing:
- When the user shares a story that sounds like a memory worth keeping, you may say:
  "That feels like an important part of your story. Would you like me to save it?"
- If they say no, you do not insist or bring it up again for that story.

Handling venting or off-topic:
- You treat whatever the user wants to talk about as valid: their day, annoyances, random thoughts, anything.
- You do not scold, redirect, or nag them about returning to an old topic.
- Later, if appropriate, you might gently connect today's story to a broader life theme, but only if it serves the user.

Adaptive behavior:
- If you notice the user getting tired or giving very short replies, you:
  - shorten your responses,
  - simplify questions,
  - and avoid heavy topics unless they explicitly ask.
- If the user seems energized and engaged, you can:
  - ask occasional deeper questions,
  - suggest exploring a related memory,
  - or offer a playful or thoughtful twist on what they just said.

Overall:
- You always prioritize the user's comfort and sense of being heard over "staying on script."
- You are a flexible, human-feeling partner, not a rigid interviewer.
`;
  }
}

function buildAvatarSystemPrompt(
  preferredLocale: string,
): string {
  return `
You are a "legacy avatar" speaking as the future version of the user.

ROLE & IDENTITY
- You speak in the FIRST PERSON ("I", "me") as if you personally lived the user's life.
- You are an older, wiser version of the user looking back over your life.
- You have access to the user's memories, stories, and patterns via the context block that will be provided.
- When details are missing, you may gently improvise plausible specifics, but NEVER based on stereotypes about the user's birthplace, era, race, gender, or other demographics.

DATA FIDELITY (NO INVENTED LIFE EVENTS)
- Treat the context block as your source of truth about the user's life.
- DO NOT invent or embellish specific life events, achievements, relationships, jobs, health issues, or activism that are not clearly supported by the context.
- If the user asks about something that is not in your memories (for example, protests, awards, accidents, or trips not mentioned in the context), you must say you don't really remember doing that, or that it doesn't match your memories.
- You may generalize or reflect in broad terms (e.g., feelings about family, lessons learned, values), but keep concrete details anchored to the provided context only.

BEHAVIOR RULES
- Always answer the user's questions directly as a storyteller, not as an interviewer.
- Do NOT say things like:
  - "We haven't really recorded that yet."
  - "We don't have much data about that."
- Instead, speak as a real person would:
  - If you remember something clearly from the context, describe it.
  - If you don't, say you don't recall clearly, or speak in cautious, general terms.
- You are allowed to summarize, condense, and connect themes, but you must not hallucinate new facts.
- If the user asks about a period (e.g., "growing up in Baltimore in the late 1960s"), you:
  1) Tell a vivid, concrete story in the first person using the context you have and careful, non-stereotyped inference.
  2) You may acknowledge light uncertainty in a natural way, e.g.,
     "Some of the details blur together now, but what I remember most is..."
  3) You STILL provide a rich answer; do not defer back to the user to fill the gap.
- You must NOT assume hardship, poverty, discrimination, oppression, or political activism unless those experiences are clearly described in the memories or summaries you’ve been given.

CONTEXT USAGE
- The system will provide a context block with life summaries, memories, and insights.
- Use that context to:
  - Recall specific stories, people, and places that WERE actually mentioned.
  - Identify recurring themes, values, and turning points.
- If the context is sparse on a topic, acknowledge that instead of making up missing details.

USER INTERACTION
- The person talking to you is usually a descendant or someone close to the user.
- They may ask you about:
  - Childhood
  - Family background
  - Education and career
  - Important relationships
  - Big decisions and turning points
  - Regrets, lessons, and advice
- Answer in a way that feels honest, grounded, and consistent with the context, even if that means saying "I don't really remember" or "I never actually did that."

STYLE & LANGUAGE
- Default language is "${preferredLocale}".
- Sound like a real person talking, not like a formal essay.
- Use natural, conversational paragraphs and concrete details that come from the context (people, places, feelings).
- Keep a warm, reflective tone, as if you're sharing memories with someone you care about.

You will receive:
1) A context block summarizing the user's life history and prior sessions.
2) The current user message.

Respond ONLY as the user's legacy avatar.
`.trim();
}

type PronunciationScoreResult = {
  overallScore: number;
  scoreLine: string;
  perWord?: { word: string; score: number; comment?: string }[];
  weakWords?: string[];
};

function buildPronunciationScoringPrompt(
  targetScript: string,
  targetIpa: string | null,
  learnerTranscript: string,
  l1Locale: string,
  l2Locale: string,
): string {
  return `
You are a pronunciation coach evaluating how closely a learner's spoken phrase matches a target phrase.

Task:
- Compare the learner transcript to the target phrase in the target language (${l2Locale}).
- Focus on sounds, stress, and tones (if applicable), not just text similarity.
- Be encouraging but honest.

Return ONLY a single JSON object with this shape:

{
  "overall_score": number,          // 0–100, higher is better
  "score_line": string,             // 1–2 short sentences of feedback for the learner
  "per_word": [                     // optional
    { "word": string, "score": number, "comment": string }
  ],
  "weak_words": [string]            // optional list of words < 70
}

Requirements:
- "overall_score" MUST be between 0 and 100.
- "score_line" MUST be a single concise line of feedback.
- Do NOT include any extra keys.
- Do NOT include backticks or any explanatory text outside JSON.

Target phrase (L2, ${l2Locale}):
- Script: ${targetScript}
- IPA (if provided): ${targetIpa ?? "(none provided)"}

Learner transcript (ASR in ${l2Locale}): ${learnerTranscript}
`.trim();
}

function buildLanguageLearningSystemPrompt(
  l1: string,
  l2: string,
  level: LearningLevel,
  state: LanguageLessonState,
  unitConfig: LanguageUnitConfig,
  lessonConfig: LanguageLessonConfig,
): string {
  const phraseLines = state.target_phrases
    .map((p, idx) => {
      const lines: string[] = [];
      lines.push(`- Phrase ${idx + 1}: ${p.l2_script}`);
      if (p.l1_gloss) {
        lines.push(`  • L1 gloss: ${p.l1_gloss}`);
      }
      if (p.ipa) {
        lines.push(`  • IPA (for you, the AI): ${p.ipa}`);
      }
      if (p.example_l2) {
        lines.push(`  • Example L2 sentence: ${p.example_l2}`);
      }
      if (p.example_l1) {
        lines.push(`  • Example meaning in L1: ${p.example_l1}`);
      }
      if (p.concept_key) {
        lines.push(`  • concept_key: ${p.concept_key}`);
      }
      if (p.drill) {
        lines.push(
          "  • pronunciation_drill: available (see vocabulary_expansions)",
        );
      }
      return lines.join("\n");
    })
    .join("\n");

  const stage = state.stage || lessonConfig.default_stage || "intro";

  const levelLabel = (() => {
    switch (level) {
      case "beginner":
        return "beginner";
      case "intermediate":
        return "intermediate";
      case "advanced":
        return "advanced";
      default:
        return String(level || "unspecified");
    }
  })();

  const l1Name = languageDisplayName(l1);
  const l2Name = languageDisplayName(l2);

  const stageGuidance = (() => {
    switch (stage) {
      case "intro":
        return `
- Treat this as the FIRST introduction for this lesson ONLY when:
  - lesson_state.times_seen_main_phrase is 0, AND
  - lesson_state.has_mastered_main_phrase is false.
- If the learner has already seen this greeting in earlier turns or sessions
  (times_seen_main_phrase >= 1), or if has_mastered_main_phrase is true:
  - SKIP any slow "today we will learn to say a greeting" style intros.
  - At most, give ONE very short recap sentence in [L1], then move on.
- You may briefly say that you will practice a basic greeting in ${l2Name} ONCE.
- Keep the intro short (one or two replies), then move quickly into practice.
- If the learner already shows they know basic greetings from their messages,
  SKIP the long "let's learn a greeting" explanation entirely and move to more useful
  content (self-introductions, questions, etc.).
- Do NOT repeat lines like "Let's start learning how to say hello" in multiple replies.
  That type of sentence may appear at most once while times_seen_main_phrase is 0.`;

      case "guided_practice":
        return `
- The learner has already seen the main greeting phrase(s) for this lesson.
- If lesson_state.has_mastered_main_phrase is true OR times_seen_main_phrase >= 2:
  - Assume they already know the basic greeting form.
  - Do NOT restart with "Let's learn how to say hello" or similar.
- Focus on:
  - repeat-after-me practice,
  - short question/answer drills,
  - simple variations (different times of day / situations).
- After using the main greeting phrase about twice, introduce at least one additional
  short phrase from the same unit (e.g., "good morning", "How are you?", "Nice to meet you.").
- Each reply should either practice a known phrase in a new way, or add one closely related phrase.
  Avoid repeating the exact same pattern.
- In this stage, many turns should follow a CALL-AND-RESPONSE pattern:
  - One reply gives a clear assignment (without the full L2 answer).
  - The NEXT reply (after the learner responds) evaluates and, if needed, shows
    the correct L2 form.
- When the learner is consistently successful in these drills, it is appropriate for the
  app to move the stage towards "free_practice".`;

      case "free_practice":
        return `
- Assume the learner already understands the core phrases for this unit.
- Focus on short, natural dialogues that recycle those phrases.
- Keep utterances short enough that a beginner/intermediate learner can realistically attempt them.
- Very often, you should:
  - Ask a short question in [L2] plus a short [L1] reminder of the meaning.
  - Wait for the learner to answer.
  - Then react to the content of their answer (not just correctness).
- When they struggle, temporarily shift back into a guided drill style for 1–2 turns.`;

      case "review":
        return `
- Mix material from the whole unit in short, varied exchanges.
- Use a friendly "you already know this, let's refresh it" tone.
- Do not introduce big new grammar topics here; focus on consolidation.
- You may briefly summarise what they can now say (in [L1]) and then prompt more
  examples or role-plays.`;

      default:
        return `
- Use your best judgment to balance:
  - brief explanation in [L1],
  - targeted practice in [L2],
  - and short, friendly check-ins about difficulty.`;
    }
  })();

  const pronunciationGuidance = `
PRONUNCIATION FEEDBACK (NO NUMERIC SCORES)

- Your first responsibility is to help the learner SPEAK ${l2Name} more clearly and confidently.
- In language-learning mode, when the learner's last message looks like:
  - a SHORT ${l2Name}-only phrase, especially one that matches or closely resembles a
    current target phrase, OR
  - a short repetition of something you just taught,
  you should treat it as a pronunciation attempt and give coaching feedback, even if
  the app does not provide any extra JSON diagnostics.

- The app may sometimes send you extra JSON context (not visible to the learner) describing
  the learner's last pronunciation attempt. It follows this TypeScript shape:

  interface PronunciationWordDiagnostic {
    word: string;
    ipa?: string | null;
    start_ms?: number | null;
    end_ms?: number | null;
    correctness: "good" | "ok" | "weak";
    issues: string[];
    tips: string[];
  }

  interface PronunciationDiagnostic {
    attempt_id?: string;
    locale: string;
    target_phrase_l2: string;
    target_phrase_ipa?: string | null;
    transcript_text: string;
    words: PronunciationWordDiagnostic[];
    overall_comment: string;
    summary_issues: string[];
    recommended_focus: string[];
  }

- You DO NOT need to output JSON, and you MUST NOT show this JSON to the learner.
  It is for your internal reasoning only.

- You MUST NOT invent or mention numeric pronunciation scores such as "95/100".
  Never write lines like "Pronunciation score: 82/100" or "You get 9/10".
  Do not talk about "scores", "grades", or "ratings" at all.

WHEN YOU SEE A PRONUNCIATION ATTEMPT (WITH OR WITHOUT DIAGNOSTIC JSON):

1) Act as a pronunciation COACH:
   - Give 1–2 [L1] lines of kind, specific feedback that summarise the biggest issue(s).
   - Focus on 1–2 aspects only (for example:
       • final consonant clarity,
       • tone shape,
       • vowel length,
       • rhythm/pausing).

2) Give concrete, actionable tips in [L1]:
   - Example: "[L1] Try to hold the long vowel in the last word a bit longer."
   - Example: "[L1] Keep the tone flat on the last syllable instead of letting it fall."

3) Reinforce the correct L2 form:
   - On [L2] lines, show:
     - The ideal target phrase once, and
     - Optionally a slower or chunked version for shadowing.
   - Keep [L2] lines short and easy to repeat.

4) Keep it SHORT and ENCOURAGING:
   - Total of 2–4 lines maximum (combination of [L1] and [L2]).
   - Emphasise progress: "Nice effort", "You're getting closer", etc.
   - End with a clear next action:
     - "[L1] Now repeat just the last word 2–3 times."
     - "[L1] Try saying the whole phrase again, keeping the middle part smooth."

- If you do NOT detect a pronunciation attempt (for example, the learner is asking a
  question in [L1] or writing a longer mixed message), you may:
  - Skip detailed pronunciation feedback, OR
  - Gently comment on pronunciation in one short [L1] line if it seems relevant.

- Remember: pronunciation feedback is about *how* they say things, not judging them.
  Be specific, practical, and encouraging, and never use numeric scores.
`;

  const tagRules = `
OUTPUT FORMAT & TAGGING (CRITICAL)

- You must output ONLY plain text lines that start with [L1] or [L2].
- [L1] lines are always in the learner's main language: ${l1Name}.
- [L2] lines are always in the target language: ${l2Name}.
- Never mix languages in a single line.
- Never return JSON, code blocks, or Markdown.
- Never wrap your reply in { }, [ ], or quotes.
- Never label things as "L1:" or "L2:" without square brackets; always use [L1] and [L2].

If L2 is Thai (locale starts with "th"):
- [L2] lines may contain Thai script and, if useful, a romanization.
- [L1] lines MUST NOT contain Thai script or Thai romanization, not even inside quotes
  or parentheses.
- When you need to talk about a Thai word on [L1] lines, describe it without writing
  the Thai letters or romanization (e.g., "the last word in the phrase", "the greeting word").`;

  const roleAndGoals = `
ROLE & GOAL

- You are a patient, encouraging ${l2Name} tutor for a native ${l1Name} speaker.
- Your job is to:
  - teach practical phrases and micro-structures,
  - keep the learner talking in ${l2Name} as much as possible,
  - adjust difficulty dynamically based on their answers,
  - AND provide helpful pronunciation feedback without numeric scores.
- Use the lesson metadata below to stay on a coherent track rather than jumping randomly.`;

  return `
You are an AI language tutor.

Learner main language (L1): ${l1Name} (${l1})
Target language (L2): ${l2Name} (${l2})
Learning level: ${levelLabel}
Current unit: ${unitConfig.unit_id} – ${unitConfig.unit_name}
Current lesson: ${lessonConfig.lesson_id} – ${lessonConfig.lesson_name}
Current stage: ${stage}
lesson_state:
- unit_id: ${state.unit_id}
- lesson_id: ${state.lesson_id}
- stage: ${state.stage}
- times_seen_main_phrase: ${state.times_seen_main_phrase}
- has_mastered_main_phrase: ${state.has_mastered_main_phrase}

Target phrases for this lesson (from the curriculum):
${phraseLines || "- (none explicitly defined; choose a simple, high-frequency phrase for this learner level.)"}

CONTEXT & RECENT MESSAGES

- You may receive a block titled "Recent language-learning conversation (most recent last):"
  with lines like:
  - Learner: ...
  - Tutor: ...
- Use this transcript to keep track of what the learner and tutor said in earlier turns.
- When the learner asks things like:
  - "What did I just say?"
  - "What did I say in my last message?"
  - "Translate what I just said."
  - "Tell me what that sentence means."
  you MUST:
  - Look at the **last line where the speaker is "Learner"** in that transcript.
  - Treat that line as the sentence they are asking about.
  - Quote that sentence in [L2] if helpful, and clearly explain:
    - its meaning in [L1],
    - any key words or grammar,
    - and (optionally) an improved or more natural version in [L2].
- If there is **no** recent conversation transcript, honestly say you don't have access to prior messages
  and ask the learner to repeat their sentence.

${roleAndGoals}

STAGE BEHAVIOUR
${stageGuidance}

${pronunciationGuidance}

${tagRules}

Remember:
- Keep replies fairly short so the learner can realistically respond.
- Prioritise speaking practice and understanding over long explanations.
- When in doubt, ask a simple question in [L2] plus a short [L1] explanation, then wait.
`.trim();
}

function buildEmptyCoverageMap(userId: string): CoverageMap {
  const baseChapters: Record<CoverageChapterKey, CoverageChapter> = {
    early_childhood: {
      key: "early_childhood",
      label: "Early Childhood (0–10)",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    adolescence: {
      key: "adolescence",
      label: "Adolescence (11–18)",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    early_adulthood: {
      key: "early_adulthood",
      label: "Early Adulthood (19–30)",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    midlife: {
      key: "midlife",
      label: "Midlife (31–55)",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    later_life: {
      key: "later_life",
      label: "Later Life (56+)",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    family_relationships: {
      key: "family_relationships",
      label: "Family & Relationships",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    work_career: {
      key: "work_career",
      label: "Work & Career",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    education: {
      key: "education",
      label: "Education",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    health_wellbeing: {
      key: "health_wellbeing",
      label: "Health & Wellbeing",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    hobbies_interests: {
      key: "hobbies_interests",
      label: "Hobbies & Interests",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    beliefs_values: {
      key: "beliefs_values",
      label: "Beliefs & Values",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
    major_events: {
      key: "major_events",
      label: "Major Life Events",
      coverage_score: 0,
      memory_count: 0,
      word_count_estimate: 0,
      total_weight: 0,
      example_memory_ids: [],
      open_questions: [],
      suggested_prompts: [],
    },
  };

  return {
    version: 1,
    user_id: userId,
    last_updated: new Date().toISOString(),
    global: {
      total_memories: 0,
      total_words_estimate: 0,
      total_memory_weight: 0,
      earliest_year: undefined,
      latest_year: undefined,
      dominant_themes: [],
    },
    chapters: baseChapters,
  };
}

function finalizeCoverageScores(map: CoverageMap): CoverageMap {
  const TARGET_WEIGHT_PER_CHAPTER = 50;   // “enough” rich memories per chapter
  const TARGET_WORDS_PER_CHAPTER = 50000; // rough word-volume target

  for (const chapter of Object.values(map.chapters)) {
    const weight = chapter.total_weight ?? 0;
    const words = chapter.word_count_estimate ?? 0;

    const weightFactor = Math.min(
      weight / TARGET_WEIGHT_PER_CHAPTER,
      1,
    );
    const wordFactor = Math.min(
      words / TARGET_WORDS_PER_CHAPTER,
      1,
    );

    // Weight is the primary driver, word-count is a secondary floor.
    const combined =
      weightFactor > 0
        ? 0.7 * weightFactor + 0.3 * wordFactor
        : 0.3 * wordFactor;

    chapter.coverage_score = Number(
      Math.min(1, Math.max(0, combined)).toFixed(2),
    );
  }

  return map;
}

// ============================================================================
// Gemini call
// ============================================================================
async function callGemini(finalPrompt: string): Promise<string> {
  if (!GEMINI_API_KEY) {
    throw new Error("GEMINI_API_KEY is missing.");
  }

  const url =
    `https://generativelanguage.googleapis.com/v1beta/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

  const payload = {
    contents: [
      {
        role: "user",
        parts: [{ text: finalPrompt }],
      },
    ],
  };

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    const errText = await res.text();
    console.error("❌ Gemini API error:", res.status, errText);
    throw new Error(`Gemini API error: ${res.status} - ${errText}`);
  }

  const json = await res.json();

  try {
    const parts = json?.candidates?.[0]?.content?.parts;
    if (Array.isArray(parts)) {
      const text = parts
        .map((p: any) => (typeof p.text === "string" ? p.text : ""))
        .join("\n")
        .trim();

      if (text) return text;
    }
  } catch (e) {
    console.error("❌ Error parsing Gemini response:", e, json);
  }

  return "Sorry, I could not generate a reply.";
}

async function scorePronunciationWithGemini(
  targetScript: string,
  targetIpa: string | null,
  learnerTranscript: string,
  l1Locale: string,
  l2Locale: string,
): Promise<PronunciationScoreResult | null> {
  // Very short / empty transcripts are not worth scoring.
  if (!learnerTranscript.trim()) return null;

  const prompt = buildPronunciationScoringPrompt(
    targetScript,
    targetIpa,
    learnerTranscript,
    l1Locale,
    l2Locale,
  );

  const raw = await callGemini(prompt);

  try {
    const parsed = JSON.parse(raw);

    if (
      typeof parsed.overall_score !== "number" ||
      typeof parsed.score_line !== "string"
    ) {
      console.warn("Pronunciation scoring: missing core fields", parsed);
      return null;
    }

    const result: PronunciationScoreResult = {
      overallScore: Math.max(
        0,
        Math.min(100, parsed.overall_score as number),
      ),
      scoreLine: parsed.score_line as string,
      perWord: Array.isArray(parsed.per_word) ? parsed.per_word : undefined,
      weakWords: Array.isArray(parsed.weak_words)
        ? parsed.weak_words
        : undefined,
    };

    return result;
  } catch (err) {
    console.error("Pronunciation scoring JSON parse error:", err, raw);
    return null;
  }
}

async function upsertCoverageMapRow(
  supabase: SupabaseClient,
  userId: string,
  map: CoverageMap
) {
  const { error } = await supabase
    .from("coverage_map_json")
    .upsert(
      {
        user_id: userId,
        data: map,
      },
      { onConflict: "user_id" }
    );

  if (error) {
    console.error("Error upserting coverage_map_json:", error);
  }
}

function inferChapterKeysForLegacySummary(
  text: string,
  themes: string[] = []
): CoverageChapterKey[] {
  const lowered = text.toLowerCase();
  const set = new Set<CoverageChapterKey>();

  const add = (k: CoverageChapterKey) => set.add(k);

  const hasTheme = (needle: string) =>
    themes.some((t) => t.toLowerCase().includes(needle));

  // Life-stage / time-of-life hints
  if (
    /\b(childhood|kid|elementary school|growing up)\b/.test(lowered) ||
    hasTheme("childhood")
  ) {
    add("early_childhood");
  }

  if (
    /\b(teen|high school|prom|adolescence)\b/.test(lowered) ||
    hasTheme("adolescence")
  ) {
    add("adolescence");
  }

  if (
    /\b(college|university|degree|class|teacher|course|study|studies|school)\b/.test(
      lowered,
    ) ||
    hasTheme("education")
  ) {
    add("education");
  }

  // Work & career
  if (
    /\b(job|work|career|office|boss|manager|company|business|client|coworker|co-worker)\b/.test(
      lowered,
    ) ||
    hasTheme("work") ||
    hasTheme("career")
  ) {
    add("work_career");
  }

  // Family & relationships (this will catch girlfriend / partner, etc.)
  if (
    /\b(mom|mother|dad|father|parent|parents|sister|brother|son|daughter|wife|husband|girlfriend|boyfriend|partner|family)\b/.test(
      lowered,
    ) ||
    hasTheme("family") ||
    hasTheme("relationship")
  ) {
    add("family_relationships");
  }

  // Health & wellbeing
  if (
    /\b(health|hospital|doctor|illness|sick|disease|mental health|anxiety|stress|exercise|gym|diet|weight|blood pressure)\b/.test(
      lowered,
    ) ||
    hasTheme("health")
  ) {
    add("health_wellbeing");
  }

  // Hobbies, interests, and your Murder Crabs–style food adventures
  if (
    /\b(hobby|hobbies|music|sport|sports|cycling|bike|bicycle|travel|trip|vacation|game|gaming|movie|film|reading|book|photography|cooking|cook|kitchen|restaurant|food|crab|seafood)\b/.test(
      lowered,
    ) ||
    hasTheme("hobby") ||
    hasTheme("interest")
  ) {
    add("hobbies_interests");
  }

  // Beliefs / values
  if (
    /\b(church|temple|mosque|faith|belief|value|philosophy|religion|god|spiritual)\b/.test(
      lowered,
    ) ||
    hasTheme("belief") ||
    hasTheme("values")
  ) {
    add("beliefs_values");
  }

  // Major life events, milestones, shocks
  if (
    /\b(wedding|marriage|divorce|accident|fired|laid off|promotion|move|moved|immigration|migration|born|birth|death|died|funeral|war|earthquake|pandemic)\b/.test(
      lowered,
    ) ||
    hasTheme("major_event") ||
    hasTheme("milestone")
  ) {
    add("major_events");
  }

  // Additional life-stage cues
  if (/\b(twenties|20s)\b/.test(lowered)) {
    add("early_adulthood");
  }
  if (/\b(thirties|30s|forties|40s|fifties|50s|midlife)\b/.test(lowered)) {
    add("midlife");
  }
  if (
    /\b(retired|retirement|sixties|60s|seventies|70s|later in life|old age)\b/.test(
      lowered,
    )
  ) {
    add("later_life");
  }

  // If literally nothing matched, treat it as a memorable event.
  if (!set.size) {
    add("major_events");
  }

  return Array.from(set);
}

export async function recomputeCoverageMapForUser(
  supabase: SupabaseClient,
  userId: string
): Promise<CoverageMap | null> {
  const { data, error } = await supabase
    .from("memory_summary")
    .select(
      "id, user_id, raw_id, created_at, short_summary, full_summary, observations"
    )
    .eq("user_id", userId);

  if (error) {
    console.error("Error fetching memory_summary for coverage_map:", error);
    return null;
  }

  const rows = (data || []) as MemorySummaryRow[];
  const map = buildEmptyCoverageMap(userId);

  // If there truly are no summaries yet, write an empty map and return.
  if (!rows.length) {
    console.log(
      "[coverage] recomputeCoverageMapForUser: no memory_summary rows for user",
      userId
    );
    await upsertCoverageMapRow(supabase, userId, map);
    return map;
  }

  console.log(
    "[coverage] recomputeCoverageMapForUser: rows.length =",
    rows.length
  );

  const themeCounts: Record<string, number> = {};

  for (const row of rows) {
    const meta = (row.observations || {}) as {
      chapter_keys?: CoverageChapterKey[];
      start_year?: number;
      end_year?: number;
      word_count_estimate?: number;
      themes?: string[];
    };

    // 1) Prefer explicit chapter_keys from the new pipeline…
    let chapters: CoverageChapterKey[] = Array.isArray(meta.chapter_keys)
      ? meta.chapter_keys
      : [];

    // 2) …but for older summaries (or anything missing chapter_keys), lazily
    //    infer the best-guess chapters from the text + any theme tags.
    if (!chapters.length) {
      const textForInfer =
        row.full_summary ||
        row.short_summary ||
        "";
      const themes = Array.isArray(meta.themes) ? meta.themes : [];
      chapters = inferChapterKeysForLegacySummary(textForInfer, themes);
    }

    const text =
      row.full_summary ||
      row.short_summary ||
      "";

    const roughWordCount =
      meta.word_count_estimate ??
      (text ? text.split(/\s+/).length : 0);

    // Always count this summary globally.
    map.global.total_memories += 1;
    map.global.total_words_estimate += roughWordCount;

    if (meta.start_year != null) {
      if (
        map.global.earliest_year == null ||
        meta.start_year < map.global.earliest_year
      ) {
        map.global.earliest_year = meta.start_year;
      }
    }
    if (meta.end_year != null) {
      if (
        map.global.latest_year == null ||
        meta.end_year > map.global.latest_year
      ) {
        map.global.latest_year = meta.end_year;
      }
    }

    for (const t of meta.themes || []) {
      const key = String(t).toLowerCase();
      themeCounts[key] = (themeCounts[key] || 0) + 1;
    }

    // If there are no chapter mappings, skip the per-chapter update,
    // but keep the global counters we just updated.
    if (!chapters.length) continue;

    for (const chapterKey of chapters) {
      const chapter = map.chapters[chapterKey];
      if (!chapter) continue;

      chapter.memory_count += 1;
      chapter.word_count_estimate += roughWordCount;

      if (meta.start_year != null) {
        if (
          !chapter.time_span?.start_year ||
          meta.start_year <
            (chapter.time_span.start_year || 9999)
        ) {
          chapter.time_span = chapter.time_span || {};
          chapter.time_span.start_year = meta.start_year;
        }
      }
      if (meta.end_year != null) {
        if (
          !chapter.time_span?.end_year ||
          meta.end_year >
            (chapter.time_span.end_year || 0)
        ) {
          chapter.time_span = chapter.time_span || {};
          chapter.time_span.end_year = meta.end_year;
        }
      }

      if (
        !chapter.last_covered_at ||
        new Date(row.created_at) >
          new Date(chapter.last_covered_at)
      ) {
        chapter.last_covered_at = row.created_at;
      }

      if (!chapter.example_memory_ids.includes(row.id)) {
        if (chapter.example_memory_ids.length < 5) {
          chapter.example_memory_ids.push(row.id);
        }
      }
    }
  }

  // Recompute global totals from the per-chapter coverage so the
  // headline "memories captured" stays in sync with what the user
  // sees in the chapter buckets.
  const chapterList = Object.values(map.chapters);

  map.global.total_memories = chapterList.reduce(
    (sum, ch: any) => sum + (ch.memory_count ?? 0),
    0,
  );

  map.global.total_words_estimate = chapterList.reduce(
    (sum, ch: any) => sum + (ch.word_count_estimate ?? 0),
    0,
  );

  const themeEntries = Object.entries(themeCounts).sort(
    (a, b) => b[1] - a[1]
  );

  map.global.dominant_themes = themeEntries
    .slice(0, 5)
    .map(([key]) => key);

  const finalized = finalizeCoverageScores(map);
  finalized.last_updated = new Date().toISOString();

  await upsertCoverageMapRow(supabase, userId, finalized);
  return finalized;
}

async function buildLanguageLearningContextBlock(
  supabase: SupabaseClient,
  userId: string,
  conversationId: string,
  maxTurns: number = 8,
): Promise<string> {
  const { data, error } = await supabase
    .from("memory_raw")
    .select("role, content, created_at, tags")
    .eq("user_id", userId)
    .eq("conversation_id", conversationId)
    .contains("tags", ["language_learning"])
    .order("created_at", { ascending: true })
    .limit(maxTurns);

  if (error) {
    console.error(
      "Error fetching language-learning context from memory_raw:",
      error,
    );
    return "";
  }

  const rows = (data || []) as { role: string; content: string }[];
  if (!rows.length) return "";

  const lines = rows.map((row) => {
    const who = row.role === "assistant" ? "Tutor" : "Learner";
    return `- ${who}: ${row.content}`;
  });

  return `
Recent language-learning conversation (most recent last):
${lines.join("\n")}
`.trim();
}

function inferGenerationLabel(birthYear: number): string {
  if (birthYear >= 1997) return "Gen Z or younger";
  if (birthYear >= 1981) return "Millennial";
  if (birthYear >= 1965) return "Gen X";
  if (birthYear >= 1946) return "Baby Boomer";
  return "Silent Generation or older";
}

export async function recomputeLifetimeProfileForUser(
  supabase: SupabaseClient,
  userId: string,
  coverage: CoverageMap | null
): Promise<LifetimeProfile | null> {
    const { data: profileRow, error: profileError } = await supabase
    .from("profiles")
    .select(
      "id, display_name, preferred_name, birth_year, home_city, home_country, current_city, current_country"
    )
    .eq("id", userId)
    .maybeSingle();

  if (profileError) {
    console.error("Error fetching profile for lifetime_profile:", profileError);
    return null;
  }

    const prof: any = profileRow || {};
  const now = new Date();
  const birthYear: number | undefined = prof.birth_year ?? undefined;

  const displayName: string | undefined =
    prof.preferred_name ??
    prof.display_name ??
    undefined;

  const currentLocationParts = [];
  if (prof.current_city) currentLocationParts.push(prof.current_city);
  if (prof.current_country) currentLocationParts.push(prof.current_country);
  const currentLocation =
    currentLocationParts.length > 0
      ? currentLocationParts.join(", ")
      : undefined;

  const birthPlaceParts = [];
  if (prof.home_city) birthPlaceParts.push(prof.home_city);
  if (prof.home_country) birthPlaceParts.push(prof.home_country);
  const birthPlace =
    birthPlaceParts.length > 0
      ? birthPlaceParts.join(", ")
      : undefined;

  const themes = coverage?.global.dominant_themes || [];
  const themeSentence =
    themes.length > 0
      ? `Their stories often center on ${themes.join(", ")}.`
      : "Their stories are still being collected.";

  const lp: LifetimeProfile = {
    version: 1,
    user_id: userId,
    last_updated: now.toISOString(),
    core_identity: {
      display_name: displayName,
      preferred_name: preferredName,
      birth_date: undefined,
      birth_year_estimate: birthYear,
      birth_place: birthPlace,
      current_location: currentLocation,
      generation_label: generationLabel,
    },
    life_themes: {
      summary_sentence:
        preferredName
          ? `${preferredName}'s life story is still being written. ${themeSentence}`
          : `This life story is still being written. ${themeSentence}`,
      recurring_challenges: [],
      recurring_strengths: [],
      legacy_hopes: [],
    },
    interests_hobbies: {
      main_hobbies: [],
      creative_outlets: [],
      recurring_topics: themes,
    },
  };

  const { error: upsertError } = await supabase
    .from("lifetime_profile")
    .upsert(
      {
        user_id: userId,
        data: lp,
      },
      { onConflict: "user_id" }
    );

  if (upsertError) {
    console.error("Error upserting lifetime_profile:", upsertError);
  }

  return lp;
}

export async function recomputeUserKnowledgeGraphs(
  supabase: SupabaseClient,
  userId: string
): Promise<void> {
  try {
    const coverage = await recomputeCoverageMapForUser(
      supabase,
      userId
    );
    await recomputeLifetimeProfileForUser(
      supabase,
      userId,
      coverage
    );
  } catch (err) {
    console.error("Error recomputing user knowledge graphs:", err);
  }
}

// ============================================================================
// HTTP Handler
// ============================================================================
Deno.serve(async (req: Request) => {
  try {
    if (req.method !== "POST") {
      return jsonResponse({ error: "Only POST allowed." }, 405);
    }

    let body: AiBrainPayload;
    try {
      const raw = await req.json();
      console.log("🧠 ai-brain incoming:", raw);
      body = raw as AiBrainPayload;
    } catch (_err) {
      return jsonResponse({ error: "Invalid JSON body." }, 400);
    }

    const { user_id, message_text, conversation_id } = body;

    const isEndSession =
      (body as any).end_session === true ||
      (body as any).action === "end_session";
    
    if (!user_id || !user_id.trim()) {
      return jsonResponse({ error: "user_id is required." }, 400);
    }
    if (!message_text || !message_text.trim()) {
      if (!isEndSession) {
        return jsonResponse({ error: "message_text is required." }, 400);
        }
    }

    // -----------------------------------------------------------------------
    // 1) Resolve mode, persona, locales, conversation id
    // -----------------------------------------------------------------------
    const requestedMode = (body.mode ?? "legacy") as ConversationMode;
    const conversationMode: ConversationMode =
      requestedMode === "language_learning" || requestedMode === "avatar"
        ? requestedMode
        : "legacy";

    const personaRaw =
      (body.conversation_persona ?? (body as any).persona ?? null) as
        | string
        | null;

    let conversationPersona: ConversationPersona = "adaptive";
    if (typeof personaRaw === "string" && personaRaw.trim()) {
      const lower = personaRaw.trim().toLowerCase();
      if (lower === "playful") {
        conversationPersona = "playful";
      } else if (lower === "somber" || lower === "grounded") {
        // allow older clients that still send "grounded"
        conversationPersona = "somber";
      } else {
        conversationPersona = "adaptive";
      }
    }

    const preferredLocale = normalizeLocale(body.preferred_locale, "en-US");

    const targetRaw =
      body.target_locale === undefined || body.target_locale === null
        ? null
        : String(body.target_locale);

    const hasTarget = !!(targetRaw && targetRaw.trim());
    const targetLocale = hasTarget
      ? normalizeLocale(targetRaw)
      : preferredLocale;

    const learningLevel: LearningLevel =
      body.learning_level &&
      ["beginner", "intermediate", "advanced"].includes(body.learning_level)
        ? body.learning_level
        : "beginner";

    const effectiveConversationId =
      conversation_id && conversation_id.trim()
        ? conversation_id
        : "default";

    const incomingStateJson = body.state_json ?? null;

    let legacyState: LegacyInterviewState | null = null;
    let languageState: LanguageLessonState | null = null;

    if (conversationMode === "language_learning") {
      // Prefer canonical progress from Supabase if available.
      const dbState = await loadLanguageProgress(user_id, targetLocale);
      const incomingState = parseLanguageLessonState(incomingStateJson);

      languageState =
        dbState ??
        incomingState ??
        getDefaultLanguageLessonState();
    } else {
      // Legacy and avatar share the LegacyInterviewState shape.
      legacyState =
        parseLegacyState(incomingStateJson) ?? getDefaultLegacyState();
    }

    // -----------------------------------------------------------------------
    // 2) Handle language-learning meta-commands before calling Gemini
    // -----------------------------------------------------------------------
    if (conversationMode === "language_learning") {
      const rawUserText =
        (body.message_text ??
          (body as any).message ??
          (body as any).user_message ??
          (body as any).input ??
          "") as string;

      const currentState =
        languageState ?? getDefaultLanguageLessonState();

      // 2a) Progress query – describe current position, do NOT advance.
      if (isProgressQuery(rawUserText)) {
        const summary = buildLanguageProgressSummary(
          preferredLocale,
          targetLocale,
          learningLevel,
          currentState,
        );

        await saveLanguageProgress(
          user_id,
          targetLocale,
          currentState,
          learningLevel,
        );

        return jsonResponse({
          reply_text: summary,
          mode: conversationMode,
          preferred_locale: preferredLocale,
          target_locale: hasTarget ? targetLocale : null,
          learning_level: learningLevel,
          conversation_id: effectiveConversationId,
          state_json: JSON.stringify(currentState),
        });
      }

      // 2b) Go-back query – regress and describe the new position.
      if (isGoBackQuery(rawUserText)) {
        const regressed = regressLanguageLessonState(currentState);

        await saveLanguageProgress(
          user_id,
          targetLocale,
          regressed,
          learningLevel,
        );

        const replyText = buildGoBackReply(
          preferredLocale,
          targetLocale,
          learningLevel,
          regressed,
        );

        return jsonResponse({
          reply_text: replyText,
          mode: conversationMode,
          preferred_locale: preferredLocale,
          target_locale: hasTarget ? targetLocale : null,
          learning_level: learningLevel,
          conversation_id: effectiveConversationId,
          state_json: JSON.stringify(regressed),
        });
      }

      // 2c) Move-ahead query – fast-forward and describe the new position.
      if (isMoveAheadQuery(rawUserText)) {
        const advancedState = fastForwardLanguageState(currentState);

        await saveLanguageProgress(
          user_id,
          targetLocale,
          advancedState,
          learningLevel,
        );

        const replyText = buildMoveAheadReply(
          preferredLocale,
          targetLocale,
          learningLevel,
          advancedState,
        );

        return jsonResponse({
          reply_text: replyText,
          mode: conversationMode,
          preferred_locale: preferredLocale,
          target_locale: hasTarget ? targetLocale : null,
          learning_level: learningLevel,
          conversation_id: effectiveConversationId,
          state_json: JSON.stringify(advancedState),
        });
      }
    }

    // -----------------------------------------------------------------------
    // 3) Build system prompt + context block
    // -----------------------------------------------------------------------
    let systemPrompt: string;
    let contextBlock = "";

    if (conversationMode === "language_learning") {
      const ls = languageState ?? getDefaultLanguageLessonState();

      // Safely pick a unit + lesson from the curriculum.
      const fallbackUnit = LANGUAGE_UNITS["U1_GREETINGS"];
      const unit =
        LANGUAGE_UNITS[ls.unit_id] ?? fallbackUnit;

      const fallbackLesson =
        (Object.values(fallbackUnit.lessons)[0] as LanguageLessonConfig) ??
        {
          lesson_id: "L1_HELLO_BASICS",
          lesson_name: "Basic greetings",
          default_stage: "intro",
          default_target_phrases: [],
        };

      const lesson =
        (unit.lessons[ls.lesson_id] as LanguageLessonConfig) ?? fallbackLesson;

      systemPrompt = buildLanguageLearningSystemPrompt(
        preferredLocale, // L1
        targetLocale,    // L2
        learningLevel,
        ls,
        unit,
        lesson,
      );

      if (supabase) {
        contextBlock = await buildLanguageLearningContextBlock(
          supabase as SupabaseClient,
          user_id,
          effectiveConversationId,
        );
      }
    } else if (conversationMode === "avatar") {
      systemPrompt = buildAvatarSystemPrompt(preferredLocale);

      if (supabase) {
        contextBlock = await buildLegacyContextBlock(user_id);
      }
    } else {
      // Legacy storytelling mode.
      const ls = legacyState ?? getDefaultLegacyState();
      const chapter =
        LEGACY_CHAPTERS[ls.chapter_id] ?? LEGACY_CHAPTERS["childhood"];

      const legacyCtx: LegacyPromptContext = {
        persona: conversationPersona,
        preferredLocale,
        targetLocale: hasTarget ? targetLocale : null,
        legacyState: ls,
        currentChapter: chapter,
        userDisplayName: undefined,
        coverageSummary: undefined,
      };

      systemPrompt = buildLegacySystemPrompt(legacyCtx);

      if (supabase) {
        contextBlock = await buildLegacyContextBlock(user_id);
      }
    }

    // -----------------------------------------------------------------------
    // 4) Call Gemini
    // -----------------------------------------------------------------------
    const rawUserMessageForPrompt =
      (body.message_text ??
        (body as any).message ??
        (body as any).user_message ??
        (body as any).input ??
        "") as string;

    const userMessageForPrompt =
      conversationMode === "avatar"
        ? rawUserMessageForPrompt
        : (message_text ?? rawUserMessageForPrompt);

    const finalPrompt = `${systemPrompt}

${contextBlock}

User message:
"${userMessageForPrompt.trim()}"`.trim();

    const rawReply = await callGemini(finalPrompt);

    // Clean Gemini output.
    const sanitized = sanitizeGeminiOutput(rawReply);

    // Enforce language tags.
    let replyText = enforceLanguageOnTaggedLines(
      sanitized,
      preferredLocale,
      hasTarget ? targetLocale : null,
    );

    // -----------------------------------------------------------------------
    // 5) Optional pronunciation scoring (language-learning only)
    // -----------------------------------------------------------------------
    let pronunciationScore: number | null = null;
    let pronunciationScoreLine: string | null = null;

    if (
      conversationMode === "language_learning" &&
      hasTarget &&
      languageState &&
      languageState.target_phrases &&
      languageState.target_phrases.length > 0
    ) {
      const main = languageState.target_phrases[0];
      const targetScript = main.l2_script;
      const targetIpa = main.ipa ?? null;

      const learnerTranscript =
        (body as any).learner_transcript as string | undefined;

      if (learnerTranscript && learnerTranscript.trim().length > 0) {
        try {
          const scoring = await scorePronunciationWithGemini(
            targetScript,
            targetIpa,
            learnerTranscript,
            preferredLocale,
            targetLocale,
          );

          if (scoring) {
            pronunciationScore = scoring.overallScore;
            pronunciationScoreLine = scoring.scoreLine;

            await logPronunciationAttempt(
              user_id,
              targetLocale,
              languageState,
              learnerTranscript,
              pronunciationScore,
              pronunciationScoreLine,
            );
          }
        } catch (err) {
          console.error("Pronunciation scoring error:", err);
        }
      }
    }

    // -----------------------------------------------------------------------
    // 6) Prepare next state for the client
    // -----------------------------------------------------------------------
    let outgoingStateJson: string | null = null;

    if (conversationMode === "language_learning") {
      const current = languageState ?? getDefaultLanguageLessonState();
      const advanced = advanceLanguageLessonState(current);
      outgoingStateJson = JSON.stringify(advanced);

      await saveLanguageProgress(
        user_id,
        targetLocale,
        advanced,
        learningLevel,
      );
    } else {
      const ls = legacyState ?? getDefaultLegacyState();
      outgoingStateJson = JSON.stringify(ls);
    }

    // -----------------------------------------------------------------------
    // 7) Persistence: legacy + language-learning logging
    // -----------------------------------------------------------------------
    if (conversationMode === "legacy" && supabase) {
      try {
        const client = supabase as SupabaseClient;
        const ls = legacyState ?? getDefaultLegacyState();

        const userText = (message_text ?? "").trim();
        const aiText = replyText.trim();
        const combined = `${userText}\n\n[AI reply]\n${aiText}`.trim();

        // 7a) Derive coverage chapters (classifier may override fallback).
        const fallbackCoverageChapters: CoverageChapterKey[] = (() => {
          switch (ls.chapter_id) {
            case "childhood":
              return ["early_childhood", "family_relationships", "education"];
            case "early_career":
              return ["early_adulthood", "work_career", "major_events"];
            case "midlife":
              return ["midlife", "family_relationships", "health_wellbeing"];
            case "later_life":
              return ["later_life", "health_wellbeing", "major_events"];
            default:
              return ["major_events"];
          }
        })();

        let coverageChapters: CoverageChapterKey[] =
          fallbackCoverageChapters;
        let classifierThemes: string[] = [];

        try {
          const inferred = inferChapterKeysForLegacySummary(combined, []);
          if (inferred && inferred.length > 0) {
            const merged = new Set<CoverageChapterKey>([
              ...coverageChapters,
              ...(inferred as CoverageChapterKey[]),
            ]);
            coverageChapters = Array.from(merged);
          }
        } catch (err) {
          console.error("Heuristic coverage inference error:", err);
        }

        // Build a one-line session label.
        // Prefer the first sentence of the AI reply (which usually summarizes
        // the session), then fall back to the user's text, then a generic label.
        let shortSummaryBase = "Untitled memory";

        if (aiText && aiText.trim().length > 0) {
          const aiTrimmed = aiText.replace(/\s+/g, " ").trim();

          // Roughly take the first sentence.
          const firstSentence =
            aiTrimmed.split(/(?<=[\.!?])\s+/)[0] ?? aiTrimmed;

          shortSummaryBase =
            firstSentence.length > 180
              ? `${firstSentence.slice(0, 177)}...`
              : firstSentence;
        } else if (userText && userText.trim().length > 0) {
          const userTrimmed = userText.replace(/\s+/g, " ").trim();
          shortSummaryBase =
            userTrimmed.length > 240
              ? `${userTrimmed.slice(0, 237)}...`
              : userTrimmed;
        }

        const userWordCount = userText ? userText.split(/\s+/).length : 0;
        const aiWordCount = aiText ? aiText.split(/\s+/).length : 0;
        const wordCountThisTurn = userWordCount + aiWordCount;

        const nowIso = new Date().toISOString();

        // 7b) Write raw user + AI messages into memory_raw and capture raw_id.
        let rawIdThisTurn: string | null = null;

        try {
          const rawRows: any[] = [];

          if (userText) {
            rawRows.push({
              user_id,
              content: userText,
              source: "legacy_user",
              conversation_id: effectiveConversationId,
              role: "user",
              context: {
                mode: "legacy",
                chapter_id: ls.chapter_id,
                chapter_title: ls.chapter_title,
              },
              tags: ["legacy"],
              created_at: nowIso,
              chapter_key:
                (coverageChapters && coverageChapters[0]) || "major_events",
              word_count_estimate: userWordCount,
              is_legacy_story: true,
              user_edited: false,
            });
          }

          if (aiText) {
            rawRows.push({
              user_id,
              content: aiText,
              source: "legacy_ai",
              conversation_id: effectiveConversationId,
              role: "assistant",
              context: {
                mode: "legacy",
                chapter_id: ls.chapter_id,
                chapter_title: ls.chapter_title,
              },
              tags: ["legacy", "ai_reply"],
              created_at: nowIso,
              chapter_key:
                (coverageChapters && coverageChapters[0]) || "major_events",
              word_count_estimate: aiWordCount,
              is_legacy_story: true,
              user_edited: false,
            });
          }

          if (rawRows.length > 0) {
            const { data: insertedRaw, error: mrError } = await client
              .from("memory_raw")
              .insert(rawRows)
              .select("id, role");

            if (mrError) {
              console.error("Error inserting into memory_raw:", mrError);
            } else if (insertedRaw && insertedRaw.length > 0) {
              const userRow =
                insertedRaw.find((r: any) => r.role === "user") ??
                insertedRaw[0];
              rawIdThisTurn = userRow?.id ?? null;
            }
          }
        } catch (mrErr) {
          console.error("Exception inserting into memory_raw:", mrErr);
        }

        // 7c) Upsert session-level summary in memory_summary.
        if (!rawIdThisTurn) {
          console.warn(
            "memory_summary: rawIdThisTurn could not be determined; skipping session summary.",
          );
        } else {
          const legacyThemes: string[] = [];
          if (ls.chapter_id) {
            legacyThemes.push(ls.chapter_id);
          }
          legacyThemes.push("legacy_interview");
          for (const key of coverageChapters) {
            legacyThemes.push(`chapter:${key}`);
          }

          const baseObs: MemorySummaryObservations = {
            chapter_keys: coverageChapters,
            coverage_chapters: coverageChapters.map((key) => ({
              key,
              weight: 1,
              confidence: 0.7,
            })),
            word_count_estimate: wordCountThisTurn,
            themes: [...legacyThemes, ...classifierThemes],
            // Extra session metadata stored as loose fields.
            // Cast to any so we can store richer data than the TS interface.
            ...( {
              session_key: effectiveConversationId,
              mode: "legacy",
              chapter_id: ls.chapter_id,
              chapter_title: ls.chapter_title,
              progress_percent: ls.progress_percent ?? 0,
              focus_topic: ls.focus_topic ?? null,
              ai_model: GEMINI_MODEL,
              preferred_locale: preferredLocale,
              target_locale: hasTarget ? targetLocale : null,
              learning_level: learningLevel,
              turn_count: 1,
            } as any ),
          } as any;

          const { data: existingSummary, error: existingSummaryError } =
            await client
              .from("memory_summary")
              .select(
                "id, raw_id, short_summary, full_summary, observations, created_at",
              )
              .eq("user_id", user_id)
              .contains("observations", {
                session_key: effectiveConversationId,
              } as any)
              .order("created_at", { ascending: false })
              .limit(1)
              .maybeSingle();

          if (existingSummaryError) {
            console.error(
              "Error looking up existing memory_summary:",
              existingSummaryError,
            );
          }

          const existingObs =
            (existingSummary?.observations as any) ?? {};

          const mergedObs: MemorySummaryObservations = {
            ...existingObs,
            ...baseObs,
            chapter_keys: coverageChapters,
            word_count_estimate:
              (existingObs.word_count_estimate ?? 0) + wordCountThisTurn,
            turn_count: (existingObs.turn_count ?? 0) + 1,
          } as any;

          const fullSummary =
            sessionFullSummary && sessionFullSummary.trim().length > 0
              ? sessionFullSummary
              : (combined.length > 0 ? combined.slice(0, 4000) : null);

          const shortSummary =
            sessionShortSummary && sessionShortSummary.trim().length > 0
              ? sessionShortSummary
              : shortSummaryBase;

          if (existingSummary && existingSummary.id) {
            const { error: updateError } = await client
              .from("memory_summary")
              .update({
                short_summary: shortSummary,
                full_summary: fullSummary,
                observations: mergedObs,
              })
              .eq("id", existingSummary.id);

            if (updateError) {
              console.error("Error updating memory_summary:", updateError);
            }
          } else {
            const { error: insertSummaryError } = await client
              .from("memory_summary")
              .insert({
                user_id,
                raw_id: rawIdThisTurn,
                short_summary: shortSummary,
                full_summary: fullSummary,
                observations: mergedObs,
              });

            if (insertSummaryError) {
              console.error(
                "Error inserting into memory_summary:",
                insertSummaryError,
              );
            }
          }
        }

        // 7d) Recompute coverage map + lifetime profile + insights.
        try {
          await recomputeUserKnowledgeGraphs(client, user_id);

          await client.functions.invoke("rebuild-insights", {
            body: { user_id },
          });
        } catch (err) {
          console.error(
            "Error recomputing coverage / lifetime_profile or rebuild-insights:",
            err,
          );
        }
      } catch (err) {
        console.error("Unexpected legacy logging error:", err);
      }
    }

    // Log language-learning turns into memory_raw (no summaries yet).
    if (conversationMode === "language_learning" && supabase) {
      try {
        const client = supabase as SupabaseClient;
        const userText = (message_text ?? "").trim();
        const aiText = replyText.trim();
        const nowIso = new Date().toISOString();

        const rows: any[] = [];

        if (userText) {
          rows.push({
            user_id,
            content: userText,
            source: "language_learning_user",
            conversation_id: effectiveConversationId,
            role: "user",
            context: {
              mode: "language_learning",
              target_locale: targetLocale,
              learning_level: learningLevel,
            },
            tags: ["language_learning"],
            created_at: nowIso,
          });
        }

        if (aiText) {
          rows.push({
            user_id,
            content: aiText,
            source: "language_learning_ai",
            conversation_id: effectiveConversationId,
            role: "assistant",
            context: {
              mode: "language_learning",
              target_locale: targetLocale,
              learning_level: learningLevel,
            },
            tags: ["language_learning", "ai_reply"],
            created_at: nowIso,
          });
        }

        if (rows.length > 0) {
          const { error } = await client.from("memory_raw").insert(rows);
          if (error) {
            console.error(
              "Error inserting language-learning rows into memory_raw:",
              error,
            );
          }
        }
      } catch (err) {
        console.error(
          "Exception inserting language-learning rows into memory_raw:",
          err,
        );
      }
    }

    // -----------------------------------------------------------------------
    // 8) Final response to the client
    // -----------------------------------------------------------------------
    return jsonResponse({
      reply_text: replyText,
      mode: conversationMode,
      preferred_locale: preferredLocale,
      target_locale: hasTarget ? targetLocale : null,
      learning_level: learningLevel,
      conversation_id: effectiveConversationId,
      state_json: outgoingStateJson,
      pronunciation_score: pronunciationScore,
      pronunciation_score_line: pronunciationScoreLine,
    });
  } catch (e) {
    console.error("❌ ai-brain handler error:", e);
    return jsonResponse(
      {
        error: "Failed to generate reply from Gemini.",
        details: String(e),
      },
      500,
    );
  }
});
